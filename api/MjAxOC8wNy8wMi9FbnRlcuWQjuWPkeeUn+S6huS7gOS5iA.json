{"title":"Enter后发生了什么","date":"2018-07-01T16:00:00.000Z","date_formatted":{"ll":"Jul 2, 2018","L":"07/02/2018","MM-DD":"07-02"},"link":"2018/07/02/Enter后发生了什么","tags":["计算机网络"],"categories":["计算机网络"],"updated":"2020-02-09T08:37:16.000Z","content":"<blockquote>\n<p>日常每个人都在会在网上查找我们所需要的东西，资料，文献，历史….. whatever。那我们在查找时会访问网站，而在搜索框输入然后回车时就会得到我们想要的东西（当然并不时常都会如意）。而在我们回车然后出现结果的短短秒级内究竟发生了什么呢。</p>\n</blockquote>\n<h4 id=\"enter\">Enter<a href=\"#enter\" title=\"Enter\"></a></h4><p>在网上找资料时发现了一个变态的东西当然不是我想要的那种，博主居然真的时从enter键按下的瞬间开始算起的。enter被按回最低点时，回车键的点流回路被闭合，然后电流进入了键盘的逻辑电路系统，这时系统会扫描每个键的状态，对按键开关的电位弹跳变化进行噪音消除，转换为键盘码值。回车键的码值是13。键盘控制器在得到码值之后，将其编码，传输过程通过通用串行总线（USB）或蓝牙，（大概也就是有线键盘和无线键盘的区别）…… </p>\n<h4 id=\"关于输入\">关于输入<a href=\"#关于输入\" title=\"关于输入\"></a></h4><p>在用户的输入搜索时，很多时候并不是输入URL，而是直接输入文字。此时浏览器会将地址栏中的文字传输给默认的搜索引擎。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取输入内容</span><br><span class=\"line\">String string &#x3D; editText.getText().toString();</span><br><span class=\"line\">&#x2F;&#x2F;判断是否输入了内容</span><br><span class=\"line\">if (string.equals(&quot;&quot;)) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;禁止Button获得焦点与事件</span><br><span class=\"line\">    search_type_arraw_right.setClickable(true);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;判断输入的是网址还是字符串</span><br><span class=\"line\">    if (Linkify.addLinks(editText.getText(),Linkify.WEB_URLS)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;判断输入的网址中是否含有http:&#x2F;&#x2F;</span><br><span class=\"line\">        if(!string.contains(&quot;http:&#x2F;&#x2F;&quot;)) &#123;</span><br><span class=\"line\">            webView.loadUrl(&quot;http:&#x2F;&#x2F;&quot;+string);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            webView.loadUrl(string);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"dns解析\">DNS解析<a href=\"#dns解析\" title=\"DNS解析\"></a></h4><p><img src=\"https://segmentfault.com/img/bVYTXW?w=805&h=478\" class=\"φcy\" alt=\"image\"></p>\n<ul><li>得到域名后浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将会结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。</li>\n<li>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在windows中可以通过c:\\windows\\System32\\drivers\\etc\\hosts文件来设置，你可以将任何域名解析到任何能过访问的IP地址。如果你在这里制定了一个域名对应的IP地址，那么浏览器回首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改域名解析来把特定的域名解析到他指定的IP地址，导致这些域名被劫持。</li>\n<li>这导致早期的Windows版本中出现过很严重的问题，而且对于一般没有太多计算机知识的用户来说，出现问题后很难发现，即使发现也很难自己解决，所以Windows7中将hosts文件设置成了只读的，防止这个文件被更改</li>\n<li>在Linux中这个配置文件是etc/hosts，修改这个文件可以到达同样的目的，当解析到这个配置文件中的某个域名时，操作系统会在缓存中缓存这个解析结果，缓存时间同样是受这个域名的实效时间和缓存的空间大小控制的。</li>\n<li>前面两个步骤都是在本机完成的，如果本机中无法完成域名的解析，就会真正请求域名服务器来解析这个域名。</li>\n<li>我们的网络配置中都会有“DNS服务器地址”这一项，这个地址就用于解决前面两个过程无法解析时要怎么办，操作系统会把这个域名发给这里设置的LDNS，也就是本地区的域名服务器，这个DNS通常都提供个本地互联网接入的一个DNS解析服务，如果在学校接入互联网，那么DNS服务器肯定在学校，如果是在家的话，那么就是提供给你接入互联网的应用提供商，也就是移动，联通，电信啦。那么DNS通常也会在你所在城市的某个角落，通常不会很远，在Windows下可以通过ipconfig查询这个地址</li>\n<li>在Linux下则在 /etc/resolv.conf下这里不贴图了，可以自己试试</li>\n<li>这个专门的域名解析服务器性能都会很好（当然了你付钱了嘛）它们一般会缓存域名解析结果，缓存时间是受域名失效时间控制的，一般缓存空间不是影响域名失效的主要因素，大概80%的域名解析都到这里就完成了，所以LDNS承担了主要的域名解析工作。</li>\n<li>万一还没解析成功怎么办，还有20%怎么解析呢，如果LDNS仍没有命中，就直接到root server域名服务器请求解析</li>\n<li>根域名服务器返回给本地域名服务器一个所查询的主域名服务器地址（gTLD）gTLD是国际顶级域名服务器，如com，cn，org….，全球只有13台（而且大多在美国，日本一台，欧洲两台，这件事比较有意思，可以搜搜）</li>\n<li>本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求</li>\n<li>接受请求大gTLD服务器查找并返回此域名对应的Name server域名服务器的地址，这个NameServer通常就是注册的域名服务器，例如在某个域名服务器提供商申请的域名，那么这个域名解析任务就是由这个域名提供商的服务器完成的</li>\n<li>name server 域名服务器会查询存储的域名和ip的映射关系表，在在正常情况下都根据域名得到目标IP记录，连同一个TTL值返回个DNS Server域名服务器</li>\n<li>返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制</li>\n<li>把解析结果返回个用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。</li>\n</ul><blockquote>\n<p>简单点来说就是在输入URL后，浏览器通过DNS将URL中的主机域名解析为web服务器所对应的ip地址要先在浏览器中查询如果浏览器中有就直接使用，没有就在系统中找，在没有到路由中找，路由没有到web服务器中找，还没有就到根服务器中，当然一般前两三步就可以完成IP的解析了。</p>\n</blockquote>\n<h4 id=\"hsts\">HSTS<a href=\"#hsts\" title=\"HSTS\"></a></h4><p>历经千辛万苦终于完成了IP地址的解析，那么开始发送HTTP请求当然在之前浏览器检查自带的“预加载HSTS” （HTTP Strict-Transport-Security HTTP严格传输安全）列表，他是一个web安全策略机制，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站。而HTTPS协议其实也不尽安全，所以才会有这个hsts。还有就是如果一个网站即使不在HSTS列表里也可以要求浏览器对自己使用HSTS进行访问，浏览器再向网站发出第一个HTTP请求之后，网站会返回一个响应，请求浏览器只使用HTTPS发送请求，就是第一个请求，会导致用户被攻击，这个HSTS以后再说吧。</p>\n<h4 id=\"发送http请求\">发送HTTP请求<a href=\"#发送http请求\" title=\"发送HTTP请求\"></a></h4><p>HTTP请求是一个基于tcp协议之上的应用层协议–超文本传输协议。浏览器通过DNS获得到web服务器真的IP地址后浏览器得到IP之后，浏览器接着给这个IP地址的服务器发送了一个HTTP请求通常HTTP请求格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET http:&#x2F;&#x2F;www.cricode.com&#x2F; HTTP&#x2F;1.1     </span><br><span class=\"line\">Host: www.cricode.com     </span><br><span class=\"line\">Connection: keep-alive     </span><br><span class=\"line\">Accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8     </span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;35.0.1916.114 Safari&#x2F;537.36     </span><br><span class=\"line\">Accept-Encoding: gzip,deflate,sdch     </span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.8</span><br></pre></td></tr></table></figure><p>get请求包含了主机（host），用户代理（user-agent）用户代理就是自己的浏览器，他就是代理人。connection（连接属性）中的keep-alive表示浏览器对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次连接速度就会很快</p>\n<h4 id=\"控制传输协议tcp\">控制传输协议tcp<a href=\"#控制传输协议tcp\" title=\"控制传输协议tcp\"></a></h4><p>tcp建连接的建立（三次握手）三次握手是为了确保准确无误的送达到目的地而采用的策略。发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN、ACk的标志的数据包以示传达确认信息。最后发送端在回传一个带ACk标志的数据包，代表握手结束。如在握手中某个阶段中断，tcp协议会再次以相同顺序发送相同数据包</p>\n<h5 id=\"第一次握手\">第一次握手<a href=\"#第一次握手\" title=\"第一次握手\"></a></h5><p>客户端会向服务端发送一个tcp报文，申请打开某个端口，因为没有数据，所以这个报文仅包含一个tcp头其中SYN=1当建立一个新的连接时，SYN的标志变为1。序号：序号用来标识从客户端发送的数据字节流此时客户端进入SYN_SENT状态。</p>\n<h5 id=\"第二次握手\">第二次握手<a href=\"#第二次握手\" title=\"第二次握手\"></a></h5><p>服务端收到客户端的SYN包，也会发一个包含tcp头的报文给客户端。ACk=1；服务器确认收到信息确认序号；客户端序号+1，作为应答SYN=1；因为tcp的连接是双向的，服务器作为应答的同时请求建立连接此时服务端进入SYN_RECV状态</p>\n<h5 id=\"第三次握手\">第三次握手<a href=\"#第三次握手\" title=\"第三次握手\"></a></h5><p>ACK=1：客户端确认接收到信息<br>确认序号；服务端+1，作为应答<br>此时客户端进入ESTABLISHED状态，服务器收到ACk后会进入此状态</p>\n","prev":{"title":"mvc ,mvp,mvvm分清楚","link":"2018/08/01/mvc ,mvp,mvvm分清楚"},"next":{"title":"Sqlite","link":"2018/05/29/Sqlite"},"plink":"http://yoursite.com/2018/07/02/Enter后发生了什么/","toc":[{"id":"enter","title":"Enter","index":"1"},{"id":"关于输入","title":"关于输入","index":"2"},{"id":"dns解析","title":"DNS解析","index":"3"},{"id":"hsts","title":"HSTS","index":"4"},{"id":"发送http请求","title":"发送HTTP请求","index":"5"},{"id":"控制传输协议tcp","title":"控制传输协议tcp","index":"6"}],"copyright":{"link":"<a href=\"http://yoursite.com/2018/07/02/Enter后发生了什么/\" title=\"Enter后发生了什么\">http://yoursite.com/2018/07/02/Enter后发生了什么/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}