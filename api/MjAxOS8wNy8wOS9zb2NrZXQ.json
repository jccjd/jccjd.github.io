{"title":"socket","date":"2019-07-08T16:00:00.000Z","date_formatted":{"ll":"Jul 9, 2019","L":"07/09/2019","MM-DD":"07-09"},"link":"2019/07/09/socket","tags":["Python"],"updated":"2020-02-09T08:37:01.000Z","content":"<h3 id=\"udp\">udp<a href=\"#udp\" title=\"udp\"></a></h3><p>通信的过程肯定需要 ip 和端口的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_ip = (<span class=\"string\">'127.0.0.1'</span>, <span class=\"number\">9102</span>)</span><br></pre></td></tr></table></figure><p>建立udp连接，创建upd连接的实体,绑定address</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = socket.socket(socket.AF_INET, socket.DGRAM)</span><br></pre></td></tr></table></figure><p>收取信息，作为已经绑定的目标端，发送端一定是已知目标端的ip，当发送端发数据时</p>\n<p>会将自己的ip和端口都会一起发来,服务端确定一次接受的大小</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client_data, client_address = s.recvfrom(<span class=\"number\">1024</span>)</span><br></pre></td></tr></table></figure><p>那么这是一次接受过程</p>\n<p>当有一个发送端时，目标ip已知</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.sendto(msg.encode(),server_ip)</span><br></pre></td></tr></table></figure><ul><li>创建实体 </li>\n<li>绑定ip</li>\n<li>接受信息</li>\n<li>发送信息</li>\n</ul><p>upd 是数据报的形式进行通信，不需要进行双方回复确认，发送之后就不会对此次发送维护</p>\n<h3 id=\"tcp\">TCP<a href=\"#tcp\" title=\"TCP\"></a></h3><p>tcp 创建一个tcp连接<br>创建 一个tcp实体,参数是数据流</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">host = server.gethostname</span><br><span class=\"line\">port = <span class=\"number\">9102</span></span><br></pre></td></tr></table></figure><p>依然需要bind</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.bind((host, port))</span><br></pre></td></tr></table></figure><p>还需要个监听，允许连接个数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.listen(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure><p>当有客户端去连接该server时,会返回一个client，和客户端的ip和端口</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client, msg = serverclient.accept()</span><br></pre></td></tr></table></figure><p>如果没有客户端连接，那么就会阻塞，直到有客户端连接<br>回复客户端</p>\n<pre><code>client.send(message)</code></pre>\n<p>那么客户端的一个流程,仍然是要先建立一个socket实体</p>\n<pre><code>client = socket(socket.AF_INET,socket.STREAM)</code></pre>\n<p>然后直接连接目标地址</p>\n<pre><code>client.conn(server_ip)</code></pre>\n<p>获取服务器信息,指定大小</p>\n<pre><code>msg =  client.recv(1024)</code></pre>\n<p>关闭连接<code>client.close()</code></p>\n<p>注意的是，在TCP 连接传输数据完成，关闭连接，挥手完成后，服务器仍然要等待<br>等待两个最大存活时间,一个MSL 一般是30s，如果操作不当 会有<code>address already in use</code><br>错误<br>也就是当前的TCP服务端依然在存活，一分钟后就不会报错了</p>\n<p>具体原因 :</p>\n<p>客户端请求服务器 发送一个同步申请SYN=1,和seq=x的随机数</p>\n<p>服务端收到回复ACK=1的确认和seq=x+1,并又生成一个随机数 ack=y，和同步信号syn=1</p>\n<p>客户端回复ACK=1 随机数ack=y+1,<br>这里三次握手就建立了</p>\n<p>然后在挥手的过程中<br>客户端 发送 完成信号FIN=1，和随机数字seq=x 进入完成等待状态</p>\n<p>服务器收到回复确认信号ACK=1，和随机数字加一seq+1，并又产生一个随机数ack=y</p>\n<p>带这个过程可能服务器并没有完成数据传输，等到数据传输完成</p>\n<p>发送完成信息FIN=1，和 数字Ｍ 这就是为什么要四次挥手</p>\n<p>然后客户端在回复 给服务器发送确认ACK=1 </p>\n<p>然后结束这次通信，</p>\n<p>在客户端等待服务器信号的时候，要等待2ＭＳＬ如果fin信号丢失依然能够在服务端<br>检测到超时从新发送fin，然后回应给服务端ＡＣＫ</p>\n<p>​<br>​    </p>\n","prev":{"title":"线程","link":"2019/07/10/线程"},"next":{"title":"文件读写","link":"2019/07/09/文件读写"},"plink":"http://yoursite.com/2019/07/09/socket/","toc":[{"id":"udp","title":"udp","index":"1"},{"id":"tcp","title":"TCP","index":"2"}]}