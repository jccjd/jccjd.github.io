{"title":"线程","date":"2019-07-09T16:00:00.000Z","date_formatted":{"ll":"Jul 10, 2019","L":"07/10/2019","MM-DD":"07-10"},"link":"2019/07/10/线程","tags":["Python"],"updated":"2020-02-09T08:38:35.000Z","content":"<h3 id=\"创建一个线程\">创建一个线程<a href=\"#创建一个线程\" title=\"创建一个线程\"></a></h3><p>创建线程一般用 threading 类来创建线程，thread 模块被废弃，python3中的thread<br>模块为_thread, 下面的代码可以看到不用等待，直接执行，相当于并行执行了<br>可以提高速度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">    print(<span class=\"string\">\"----&gt;\"</span>,i)</span><br><span class=\"line\">    time.selloleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">work()</span><br><span class=\"line\">t = Thread(target=work)</span><br><span class=\"line\">t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">t2 = Thread(target=work)</span><br><span class=\"line\">t2.start()</span><br><span class=\"line\"></span><br><span class=\"line\">t3 = Thread(target=work)</span><br><span class=\"line\">t3.start()</span><br><span class=\"line\"></span><br><span class=\"line\">t4 = Thread(target=work)</span><br><span class=\"line\">t4.start()</span><br></pre></td></tr></table></figure><h3 id=\"继承实现\">继承实现<a href=\"#继承实现\" title=\"继承实现\"></a></h3><p>可以直接继承threading.Thread继承一个新子类，然后实力花后调用start(),方法<br>运行run()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> Thread</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span><span class=\"params\">(Thread)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">            print(<span class=\"string\">f'name<span class=\"subst\">&#123;i&#125;</span>'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    t = MyThread()</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\">    t2 = MyThread()</span><br><span class=\"line\">    t2.start()</span><br><span class=\"line\"></span><br><span class=\"line\">test()</span><br></pre></td></tr></table></figure><h3 id=\"同步\">同步<a href=\"#同步\" title=\"同步\"></a></h3><p>对于以上的线程，不对线程加以控制，线程的推进顺序是不可预料的，那么需要对<br>线程加以控制，使用Thread对象的Lock 和 Rlock 实现简单的线程同步，<br>多线程的优势是可以同时运行多个任务，当线程需要共享数据时，存在数据不同步<br>的问题, 加锁后会保证多线程修改不会出错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"> g_num = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test1</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> g_num</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num):</span><br><span class=\"line\">        mutex.acquire()  <span class=\"comment\"># 上锁</span></span><br><span class=\"line\">        g_num += <span class=\"number\">1</span></span><br><span class=\"line\">        mutex.release()  <span class=\"comment\"># 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"---test1---g_num=%d\"</span>%g_num)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 创建一个互斥锁</span></span><br><span class=\"line\"><span class=\"comment\"># 默认是未上锁的状态</span></span><br><span class=\"line\">mutex = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建2个线程，让他们各自对g_num加1000000次</span></span><br><span class=\"line\">p1 = threading.Thread(target=test1, args=(<span class=\"number\">1000000</span>,))</span><br><span class=\"line\">p1.start()</span><br><span class=\"line\"></span><br><span class=\"line\">p2 = threading.Thread(target=test2, args=(<span class=\"number\">1000000</span>,))</span><br><span class=\"line\">p2.start()</span><br></pre></td></tr></table></figure><h3 id=\"死锁\">死锁<a href=\"#死锁\" title=\"死锁\"></a></h3><p>python 中在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时<br>等待对方的资源就会产生死锁，比如在一个两个账户相互转钱，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,_id, balance, lock)</span>:</span></span><br><span class=\"line\">        self.id = _id</span><br><span class=\"line\">        self.balance = balance</span><br><span class=\"line\">        self.lock = lock</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">withdraw</span><span class=\"params\">(self, amount)</span>:</span></span><br><span class=\"line\">        self.balance -= amount</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deposit</span><span class=\"params\">(self, amount)</span>:</span></span><br><span class=\"line\">        self.balance += amount</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transfer</span><span class=\"params\">(_from, to, amount)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> _from.lock.acquire():</span><br><span class=\"line\">        _from.withdraw(amount)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'wait for lock'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> to.lock.acquire():</span><br><span class=\"line\">            to.deposit(amount)</span><br><span class=\"line\">            to.lock.release()</span><br><span class=\"line\">        _from.lock.release()</span><br><span class=\"line\">    print(<span class=\"string\">'finish...'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a = Account(<span class=\"string\">'a'</span>, <span class=\"number\">1000</span>, threading.Lock())</span><br><span class=\"line\">b = Account(<span class=\"string\">'b'</span>, <span class=\"number\">1000</span>, threading.Lock())</span><br><span class=\"line\">threading.Thread(target = transfer, args = (a, b, <span class=\"number\">100</span>)).start()</span><br><span class=\"line\">threading.Thread(target = transfer, args = (b, a, <span class=\"number\">200</span>)).start()</span><br></pre></td></tr></table></figure><p>下面的程序就是线程同时获取多个资源而造成的死锁<br>由于两个线程获取锁的顺序是相反的,对于互斥资源<code>lock1</code>,和<code>lock2</code><br>如果是正常推进，线程1得到<code>lock1</code>,<code>lock2</code> 执行完成后，释放资源<br>线程2 在去执行，这样是没有问题的，但是<br>在线程1 的到<code>lock1</code>时有一点延迟，导致线程2 的到了 <code>lock2</code>,那么线程1 无法继续<br>线程2同样因为<code>lock1</code>的阻塞而无法执行，这就是由于同时获取多个资源产生了死锁的过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\">lock1 = threading.Lock()</span><br><span class=\"line\">lock2 = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">thread1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> lock1:</span><br><span class=\"line\">    print(<span class=\"string\">'-----get lock1 ----'</span>)</span><br><span class=\"line\">    <span class=\"comment\"># time.sleep(0.1)</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> lock2:</span><br><span class=\"line\">        print(<span class=\"string\">'-----get lock2----'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">thread2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> lock2:</span><br><span class=\"line\">        print(<span class=\"string\">'-----get lock2----'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> lock1:</span><br><span class=\"line\">            print(<span class=\"string\">'-----get lock1----'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">t1 = threading.Thread(target=thread1)</span><br><span class=\"line\">t2 = threading.Thread(target=thread2)</span><br><span class=\"line\">t1.start()</span><br><span class=\"line\">t2.start()</span><br></pre></td></tr></table></figure><ol><li>解决方法是设置等待时间，如果超过等待时间就释放资源，</li>\n<li>给每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁，— <code>python cookbook</code></li>\n<li>编写代码时逻辑要正确</li>\n</ol><h3 id=\"操作系统中的死锁\">操作系统中的死锁<a href=\"#操作系统中的死锁\" title=\"操作系统中的死锁\"></a></h3><p>死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br>死锁是指多个进程因为竞争资源而造成的一种僵局（相互等待）,若无外力作用，这些进程都将无法向前推进<br>对于两个线程，他们的执行都需要资源A， 和资源B，如果他们同时分别得到了资源A，资源B，那么此时两个线程<br>都无法执行，都在等待对方资源释放，从而造成了死锁</p>\n<h3 id=\"产生死锁的原因\">产生死锁的原因<a href=\"#产生死锁的原因\" title=\"产生死锁的原因\"></a></h3><ol><li>竞争资源（竞争临界资源）</li>\n<li>进程间的推进顺序不当（银行家算法）<h3 id=\"产生死锁的必要条件\">产生死锁的必要条件<a href=\"#产生死锁的必要条件\" title=\"产生死锁的必要条件\"></a></h3></li>\n<li>互斥条件</li>\n<li>请求与保持</li>\n<li>不剥夺</li>\n<li>环路等待<br>所以产生死锁还是比较困难的，但一旦产生就很危险</li>\n</ol><h3 id=\"进程process\">进程(Process)<a href=\"#进程process\" title=\"进程(Process)\"></a></h3><p>进程的创建过程和线程类似 进程包是 <code>multiprocessing</code><br>创建一个进程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">boo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">        print(<span class=\"string\">f'<span class=\"subst\">&#123;i&#125;</span>---'</span>,os.getpid())</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><p>​<br>​<br>    p1 = Process(target=boo)<br>    p1.start()<br>    p2 = Process(target=boo)<br>    p2.start()</p>\n<h3 id=\"进程之间不共享全局变量\">进程之间不共享全局变量<a href=\"#进程之间不共享全局变量\" title=\"进程之间不共享全局变量\"></a></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\">nums = [<span class=\"number\">11</span>, <span class=\"number\">22</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"子进程要执行的代码\"\"\"</span></span><br><span class=\"line\">    print(<span class=\"string\">\"in process1 pid=%d ,nums=%s\"</span> % (os.getpid(), nums))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">        nums.append(i)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"in process1 pid=%d ,nums=%s\"</span> % (os.getpid(), nums))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"子进程要执行的代码\"\"\"</span></span><br><span class=\"line\">    print(<span class=\"string\">\"in process2 pid=%d ,nums=%s\"</span> % (os.getpid(), nums))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    p1 = Process(target=work1)</span><br><span class=\"line\">    p1.start()</span><br><span class=\"line\">    p1.join()</span><br><span class=\"line\"></span><br><span class=\"line\">p2 = Process(target=work2)</span><br><span class=\"line\">p2.start()</span><br></pre></td></tr></table></figure><h3 id=\"进程-操作系统\">进程-操作系统<a href=\"#进程-操作系统\" title=\"进程-操作系统\"></a></h3><p><code>进程是操作系统资源分配和调度的基本单位</code><br><code>线程是cup调度和分配的基本单位</code></p>\n<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统<br>进行调度的基本单位，线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的<br>能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一点在运行中必不可少的资源<br>（程序计数器，一组寄存器和栈），线程可以与同属一个进程的其他线程共享进程的全部资源，<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>\n<p>进程包含的内容有</p>\n<ul><li>地址空间</li>\n<li>全局变量</li>\n<li>打开的文件</li>\n<li>子进程</li>\n<li>信号量</li>\n<li>账户信息</li>\n</ul><p>线程只拥有一点在运行中必不可少的资源（栈，程序计数器，寄存器，和状态）<br>线程可以共享进程的资源</p>\n<h3 id=\"进程间通信\">进程间通信<a href=\"#进程间通信\" title=\"进程间通信\"></a></h3><p>用队列来实现进程间的通信，下面是一个 简单的例子 ，两个进程对队列进行读写</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Queue</span><br><span class=\"line\"><span class=\"keyword\">import</span> os, time, random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]:</span><br><span class=\"line\">        q.put(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> q.empty():</span><br><span class=\"line\">            value = q.get(<span class=\"literal\">True</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    q = Queue()</span><br><span class=\"line\">    pw = Process(target=write, args=(q,))</span><br><span class=\"line\">    pr = Process(target=read, args=(q,))</span><br><span class=\"line\">    pw.start()    </span><br><span class=\"line\">    pw.join()</span><br><span class=\"line\">    pr.start()</span><br><span class=\"line\">    pr.join()</span><br></pre></td></tr></table></figure><h3 id=\"进程池pool\">进程池pool<a href=\"#进程池pool\" title=\"进程池pool\"></a></h3><p>当我们不确定有多少子进程的时候，那么就需要进程池，指定每次运行进程的数目，其他进程排队等待<br>直到进程池中有空闲</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"><span class=\"keyword\">import</span> os, time, random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">worker</span><span class=\"params\">(msg)</span>:</span></span><br><span class=\"line\">    print(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">po = Pool(<span class=\"number\">3</span>)  <span class=\"comment\"># 定义一个进程池，最大进程数3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"comment\"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span></span><br><span class=\"line\">    <span class=\"comment\"># 每次循环将会用空闲出来的子进程去调用目标</span></span><br><span class=\"line\">    po.apply_async(worker,(i,))</span><br><span class=\"line\">po.close()  </span><br><span class=\"line\">po.join()</span><br></pre></td></tr></table></figure><h3 id=\"协程\">协程<a href=\"#协程\" title=\"协程\"></a></h3><p>协程是微线程，协程是完全由程序操控的，线程，进程都是由OS进行操作的，对于<br>阻塞状态和可运行状态的切换，线程上下文之间的切换，都是非常消耗资源的。<br>通过yeild关键字，可让协程暂停，这个过程完全是又用户控制的，其开销要远小于<br>又OS操作的线程阻塞,<br>经典的生产者 和消费者就是一个线程写消息，一个线程取消息，通过锁来控制<br>队列和等待， 改用协程后生产者，产生消息后直接跳转到消费者开始执行，<br>待消费者生产完毕后切换回生产者继续生产，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">consumer</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    r = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        n = <span class=\"keyword\">yield</span> r</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        print(<span class=\"string\">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        r = <span class=\"string\">'200 OK'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">produce</span><span class=\"params\">(c)</span>:</span></span><br><span class=\"line\">    c.__next__()</span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">        print(<span class=\"string\">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class=\"line\">        r = c.send(n)</span><br><span class=\"line\">        print(<span class=\"string\">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class=\"line\">    c.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    c = consumer()</span><br><span class=\"line\">    produce(c)</span><br></pre></td></tr></table></figure><h3 id=\"gevent实现协程\">gevent实现协程<a href=\"#gevent实现协程\" title=\"gevent实现协程\"></a></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\">monkey.patch_all()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">coroutine_work</span><span class=\"params\">(coroutine_name)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        print(coroutine_name, i)</span><br><span class=\"line\">        time.sleep(random.random())</span><br><span class=\"line\"></span><br><span class=\"line\">gevent.joinall([</span><br><span class=\"line\">    gevent.spawn(coroutine_work,<span class=\"string\">'work1'</span>),</span><br><span class=\"line\">    gevent.spawn(coroutine_work,<span class=\"string\">'work2'</span>)</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>","prev":{"title":"装饰器","link":"2019/07/25/装饰器"},"next":{"title":"socket","link":"2019/07/09/socket"},"plink":"http://yoursite.com/2019/07/10/线程/","toc":[{"id":"创建一个线程","title":"创建一个线程","index":"1"},{"id":"继承实现","title":"继承实现","index":"2"},{"id":"同步","title":"同步","index":"3"},{"id":"死锁","title":"死锁","index":"4"},{"id":"操作系统中的死锁","title":"操作系统中的死锁","index":"5"},{"id":"产生死锁的原因","title":"产生死锁的原因","index":"6"},{"id":"产生死锁的必要条件","title":"产生死锁的必要条件","index":"7"},{"id":"进程process","title":"进程(Process)","index":"8"},{"id":"进程之间不共享全局变量","title":"进程之间不共享全局变量","index":"9"},{"id":"进程-操作系统","title":"进程-操作系统","index":"10"},{"id":"进程间通信","title":"进程间通信","index":"11"},{"id":"进程池pool","title":"进程池pool","index":"12"},{"id":"协程","title":"协程","index":"13"},{"id":"gevent实现协程","title":"gevent实现协程","index":"14"}]}