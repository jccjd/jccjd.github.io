{"title":"装饰器","date":"2019-07-24T16:00:00.000Z","link":"2019/07/25/装饰器","tags":["Python"],"categories":["Python"],"updated":"2019-10-25T08:26:44.255Z","content":"<h3 id=\"内层函数-闭包\">内层函数 闭包<a href=\"2019/07/25/装饰器#内层函数-闭包\"></a></h3><p>使用这种设计模式的一个主要优势在于， 在外部函数中对全部的参数执行检测</p>\n<h3 id=\"闭包和工厂模式\">闭包和工厂模式<a href=\"2019/07/25/装饰器#闭包和工厂模式\"></a></h3><blockquote>\n<p>闭包是使得内层函数在调用时记住他的当前环境状态</p>\n</blockquote>\n<h3 id=\"装饰器\">装饰器<a href=\"2019/07/25/装饰器#装饰器\"></a></h3><p>能够方便的增加功能，而需要对原有代码进行改动，实现了代码开发过程中的开放封闭原则</p>\n<ul>\n<li>封闭(对已经实现的功能封闭)</li>\n<li>开放(可以继续进行功能的增添)</li>\n</ul>\n<pre><code>def makeBlod(fn):\n    def waro():\n        return &quot;&lt;b&gt;&quot;+ fn() +&quot;&lt;b&gt;&quot;\n    return waro\n\ndef makeItero(fn):\n    def add():\n        return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;i&gt;&quot;\n    return add\n@makeBlod\ndef test1():\n    return (&apos;hello1&apos;)\n\n@makeItero\ndef test2():\n    return (&apos;hello2&apos;)</code></pre><p>如上装饰器加闭包实现对原有数据的包裹，显然上面的代码在@XXX将下面的函数当参数传递给个函数XXX，由XXX对函数实现包裹操作。如果目标函数是需要参数的<br>，那么在实现的过程中应该考虑到这点，在实现的时候，将不定长参数也加上, 还可以对类进行操作</p>\n<pre><code># 类装饰器\nclass Test():\n    def __init__(self, func):\n\n        print(&apos;初始化&apos;)\n        self.__func = func\n    def __call__(self, *args, **kwargs):\n        print(&quot;初始化中&quot;)\n        self.__func()\n\n@Test\ndef test10():\n    print(&apos;test10&apos;)\n\ntest10()</code></pre><p>对类进行装饰，使用装饰器可以明显看出代码的灵活性，显著提高。</p>\n<h3 id=\"装饰器路由\">装饰器路由<a href=\"2019/07/25/装饰器#装饰器路由\"></a></h3>","prev":{"title":"线性表","link":"2019/08/05/线性表"},"next":{"title":"django doc","link":"2019/06/14/django doc"},"plink":"http://jccjd.top/2019/07/25/装饰器/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/07/25/装饰器/\" title=\"装饰器\">http://jccjd.top/2019/07/25/装饰器/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}