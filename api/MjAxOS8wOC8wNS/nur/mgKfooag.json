{"title":"线性表","date":"2019-08-04T16:00:00.000Z","link":"2019/08/05/线性表","tags":["structure"],"categories":["structure"],"updated":"2019-11-01T08:59:38.653Z","content":"<h3 id=\"线性表\">线性表<a href=\"2019/08/05/线性表#线性表\"></a></h3><p>线性表，当然就是线性表啦，这个没啥好说的，见名知意，就能知道了<br>线性当然是连续的了,表啊见过没有，表就是表嘛，就是那种很特别的表。<br>一般的表就是array，在Python中也有array模块但没啥用处，list要比array强大的多，然后我要用list去实现一个array，(这看起了太TM蠢了)，这个结构不打算多写，直接开始吧</p>\n<h3 id=\"初始化array\">初始化array<a href=\"2019/08/05/线性表#初始化array\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyArray</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,size=<span class=\"number\">32</span>)</span>:</span></span><br><span class=\"line\">        self.size = size</span><br><span class=\"line\">        <span class=\"comment\"># 申请一个size大小的空间</span></span><br><span class=\"line\">        self._item = [<span class=\"literal\">None</span>]*self.size</span><br></pre></td></tr></table></div></figure>\n<p>上面的代码初始化了一个默认大小的空间，这个空间是[]来模拟的,蠢就蠢在完全可以通过访问item，对item操作就可以了<br>那就这样吧</p>\n<h3 id=\"增\">增<a href=\"2019/08/05/线性表#增\"></a></h3><p>对这个已经初始的这个数组进行一顿操作，比如增删改查，</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setitem__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> key &gt;= self.size:</span><br><span class=\"line\">        newsize = (key + <span class=\"number\">12</span>)</span><br><span class=\"line\">        newarray = [<span class=\"literal\">None</span>] * newsize</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(self.__len__()):</span><br><span class=\"line\">            newarray[i] = self.iterm[i]</span><br><span class=\"line\">        self.iterm = newarray</span><br><span class=\"line\">        self.size = newsize</span><br><span class=\"line\">        <span class=\"keyword\">del</span> newarray</span><br><span class=\"line\">    self.iterm[key] = value</span><br></pre></td></tr></table></div></figure>\n<p>上面是通过下标对这个数组进行赋值操作，需要重写<code>__setitem__</code>方法，<br>赋值的操作很简单，直接访问iterm的位置然后直接赋值，最后一行</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.iterm[key] = value</span><br></pre></td></tr></table></div></figure>\n\n\n<p>需要考虑的一点就是，初始化的大小是32，如果不指定大小就是32，当key的值大于32会数组越界的所有要加个判断,判断后是可以直接抛出异常的</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> key &gt;=self.size：</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'Index Out Of range Exception'</span>)</span><br></pre></td></tr></table></div></figure>\n<p>当然上面的代码显然不是这么做的，而是将数组扩容了，然后用了一个新数组交换数据<br>交换完后再删除了，那么在赋值时，数组的大小就改变了不用报错，自动扩容数组，显然用户体验会好很多，但是，由于重行新建了一个数组，还对原数组进行了拷贝增加了时间复杂度，和空间开销，所以在新建该数组时要先指定大小。</p>\n<h3 id=\"查\">查<a href=\"2019/08/05/线性表#查\"></a></h3><p>然后通过下标去取数组中的元素,依然要重写 <code>__getitem__</code>方法，在取值的时候要<br>验证下标的大小是否在数组的范围之内，不然很容易数组越界</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> key &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> key &lt;= self.size:</span><br><span class=\"line\">        print(<span class=\"string\">'ddd'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.iterm[key]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"改\">改<a href=\"2019/08/05/线性表#改\"></a></h3><p>改的话直接重新赋值就行了，很方便</p>\n<h3 id=\"删\">删<a href=\"2019/08/05/线性表#删\"></a></h3><p>删除的话将索引的元素设置为<code>None</code>,也并不需要特意的实现。</p>\n<blockquote>\n<p>以上是对一个线性数据结构的简单实现。全部的代码在:<br> <a href=\"https://github.com/jccjd/structure_algorithm\" target=\"_blank\" rel=\"noopener\">https://github.com/jccjd/structure_algorithm</a></p>\n</blockquote>\n","prev":{"title":"Python实现单链表","link":"2019/08/10/Python实现单链表"},"next":{"title":"装饰器","link":"2019/07/25/装饰器"},"plink":"http://jccjd.top/2019/08/05/线性表/","copyright":{"link":"<a href=\"http://jccjd.top/2019/08/05/线性表/\" title=\"线性表\">http://jccjd.top/2019/08/05/线性表/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}