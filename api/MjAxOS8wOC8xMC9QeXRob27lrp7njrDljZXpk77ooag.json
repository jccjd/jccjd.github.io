{"title":"Python实现单链表","date":"2019-08-09T16:00:00.000Z","link":"2019/08/10/Python实现单链表","tags":["structure"],"categories":["structure"],"updated":"2019-10-25T08:25:14.495Z","content":"<h3 id=\"单链表\">单链表<a href=\"2019/08/10/Python实现单链表#单链表\"></a></h3><p>链表嘛就是链接而成的一张表，由于在存储数据的时候，不见得分配的内存就是连续的，链表能将那些在物理上不连续<br>的空间给利用起来，其数据结构就是，将一块地址空间拆分来用，一部分存放数据，一部分，放指针，指针指向下个<br>数据，每增加一个元素都让最后一个元素的指针指向该元素，然后就能将这些数据串起来了，当然这些描述并不是很精准，具体定义还是书上比较精确。然后开始Python去实现这个简单的数据结构</p>\n<h3 id=\"Node类\">Node类<a href=\"2019/08/10/Python实现单链表#Node类\"></a></h3><p>首先定义一个Node类，有两个值，一个<code>value</code> 用来存放数据的，一个next用来指向下一个元素的<br>初始化为None, 很简单的一个结构</p>\n<pre><code>class Node(object):\n    def __init__(self, value=None, next=None):\n        self.value = value\n        self.next = next</code></pre><h3 id=\"LinkedList\">LinkedList<a href=\"2019/08/10/Python实现单链表#LinkedList\"></a></h3><p>开始实现链表，首先对一个链表进行初始化，确认一个根结点，下面还定义了一个 <code>tailnode</code> 用来表示尾节点，这个尾节点<br>一开始是指向None的，如果增加元素就将该节点指向新元素，</p>\n<pre><code>class LinkedList(object):\n    def __init__(self):\n        node = Node()\n        self.root = node\n        self.tailnode = None\n        self.lenght = 0</code></pre><h3 id=\"append\">append<a href=\"2019/08/10/Python实现单链表#append\"></a></h3><p>初始化完root节点后，就可以增加节点然后串成一张表了,</p>\n<pre><code>def append(self, value):\n    node = Node(value)\n    if self.tailnode is None:\n        self.root.next = node\n    else:\n        self.tailnode.next = node\n    self.tailnode = node\n    self.lenght += 1</code></pre><p>每次增加节点肯定是需要新节点的，在初始化的时候，尾节点是指向<code>None</code>的，所以<br>如果<code>self.tailnode is None</code> 说明该链表只有root节点还没有增加节点，那么<br>这时候只要将root节点的Next指向新节点<code>self.root.next = node</code>即可，每次增加节点，尾节点都移向新节点<code>self.tailnode = node</code>,最后长度加加，</p>\n<p>第二次增加节点的时候，尾节点已经不为空了，尾节点已经是一个真实的节点，然后将尾节点的next指向新节点，<code>self.tailnode.next = node</code>, 再将尾节点标志给这个新节点。在增加的话依然执行该操作。那么这就是增加节点的过程</p>\n<h3 id=\"remove\">remove<a href=\"2019/08/10/Python实现单链表#remove\"></a></h3><p>能增当然也应该能删除，删除有两种思路，是根据索引位置删除还是根据值删除，下面的实现是根据位置的删除,</p>\n<pre><code>def remove(self, index):\n    prenode = self.root\n    curnode = self.root.next\n    flagindex = 0\n    while curnode is not None:\n        if flagindex == index:\n            prenode.next = curnode.next\n            self.length -= 1\n            del curnode\n            return\n        prenode = prenode.next\n        curnode = curnode.next\n        flagindex += 1</code></pre><p>传统的单链表删除操作就是使用两个结点一前一后，当后一个节点遍历到目标时，用前一个节点去指向后一节点的next，然后del 目标节点。大概思路是这样的。</p>\n<p>上面的代码定义了，一个前驱节点 <code>prenode = self.root</code>,一开始是指向root的，然后当前节点是第一个节点<code>curnode = self.root.next</code>，是有值的,<br>还有一个游标<code>flagindex</code></p>\n<p>然后从第一个节点开始遍历，通过 <code>flagindex</code> 和<code>index</code>比较判断是否是需要删除的节点，是则删除，否则让<code>prenode</code> 和<code>curnode</code>向前走，直到找到为止<br>这里当然要对index进行校验，后面会加上。</p>\n<h3 id=\"find\">find<a href=\"2019/08/10/Python实现单链表#find\"></a></h3><p>查找比较简单遍历链表即可,这里依然根据索引去查找</p>\n<pre><code>def find(self, index):\n    flagindex = 0\n    curnode = self.node.next\n    while curnode is not None:\n        if flagindex == index:\n            return curnode.value\n        curnode = curnode.next\n        flagindex += 1</code></pre><p>可以看到这里跟remove 很相似，我们可能需要一些工具函数，比如遍历链表，得到链表的长度</p>\n<h3 id=\"遍历链表\">遍历链表<a href=\"2019/08/10/Python实现单链表#遍历链表\"></a></h3><pre><code>def iterm_node(self):\n    flagnode = self.root.next\n    while flagnode is not None:\n        yield flagnode\n        flagnode = flagnode.next\n\ndef __iter__(self):\n    for node in self.iterm_node():\n        yield node.value\ndef __len__(self):\n    return self.length</code></pre><p>这里用了生成器将结果转为一个node生成器对象，节省空间，随用随取,然后重写了<code>__iter__</code>可以直接遍历值<br>那么上面的删除和查找就可以这样写了</p>\n<pre><code>def remove(self, index):\n    flagindex = 0\n    prenode = self.root\n\n    if index &gt;= 0 and index &lt;= self.length - 1:\n        for node in self.iterm_node():\n            if flagindex == index:\n                prenode.next = node.next\n                self.length -= 1\n                del node\n            prenode = prenode.next\n            flagindex += 1\n    else:\n        raise Exception(&apos;out of range&apos;)\n\ndef find(self, index):\n    prenode = 0\n    if index &gt;= 0 and index &lt;= self.length - 1:\n        for curnode in self.iterm_node():\n            if flagindex == index:\n                return curnode\n            flagindex += 1\n        return None\n    else:\n        raise Exception(&apos;out of range&apos;)</code></pre><p>上面的代码加上了边界的判定，然后直接去遍历节点的生成器，来得到当前节点，<code>prenode</code>在每次<br>遍历时跟随，直至找到节点，然后进行删除或者输出操作。</p>\n<h3 id=\"update\">update<a href=\"2019/08/10/Python实现单链表#update\"></a></h3><p>在对数据进行更新，那么这个操作就比较简单了，直接找到节点，然后更新值即可</p>\n<pre><code>def update(self, index, value):\n    node = self.find(index)\n    if node is not None:\n        node.value = value\n    else:\n        raise Exception(&apos;the node is None&apos;)</code></pre><h3 id=\"reverse\">reverse<a href=\"2019/08/10/Python实现单链表#reverse\"></a></h3><p>反转一个链表，这个还是有点复杂的，大概思想是，需要一个<code>hepenode=None</code> 从第一个<br>有值节点<code>curnode = self.root.next</code>开始遍历，将遍历到的节点的<code>next</code>指向<code>hepenode</code>,这时的<code>hepenode</code>为<code>None</code> 然后<code>hepenode = curnode</code>,<code>curnnode</code>继续向后走 <code>curnode = curnode.next</code></p>\n<pre><code>def reverse(self):\n    curnode = self.root.next\n    helpnode = None\n\n    while curnode:\n        curnodenext = curnode.next\n\n        curnode.next = helpnode\n        if curnodenext is None:\n            self.root.next= curnode\n\n        helpnode = curnode\n        curnode = curnodenext</code></pre><p>在<code>helpnode</code> 和<code>curnode</code>之间交换时需要一个中介<code>curnodenext</code>,</p>\n<p>先将<code>curnode</code>的下一个节点存到<code>curnodenext</code>中，</p>\n<p>然后再将<code>curnode.next</code>指向<code>helpnode</code>,</p>\n<p><code>curnode</code> 赋值给<code>helpnode</code>，</p>\n<p>把存在<code>curnodenext</code>的节点在赋值给<code>curnode</code>,</p>\n<p>直到<code>curnodenext</code>为<code>None</code>时<code>root</code>指向<code>curnode</code>，</p>\n<p>这样就将一个链表给反转了， 还是比较复杂的，</p>\n","prev":{"title":"决策树","link":"2019/08/19/决策树"},"next":{"title":"线性表","link":"2019/08/05/线性表"},"plink":"http://jccjd.top/2019/08/10/Python实现单链表/","copyright":{"link":"<a href=\"http://jccjd.top/2019/08/10/Python实现单链表/\" title=\"Python实现单链表\">http://jccjd.top/2019/08/10/Python实现单链表/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}