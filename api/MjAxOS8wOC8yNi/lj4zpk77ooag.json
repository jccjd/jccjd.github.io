{"title":"Python实现循环双链表","date":"2019-08-25T16:00:00.000Z","link":"2019/08/26/双链表","tags":["structure"],"categories":["structure"],"updated":"2019-10-25T08:07:46.934Z","content":"<p><a href=\"https://github.com/jccjd\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/issues/jccjd/structure_algorithm\" alt=\"image\"></a><br><a href=\"https://996.icu\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/link-996.icu-red.svg\" alt=\"996.icu\"></a></p>\n<h4 id=\"用Python实现一个循环双链表\">用Python实现一个循环双链表<a href=\"2019/08/26/双链表#用Python实现一个循环双链表\"></a></h4><p>首先双链表的结构为如下结构</p>\n<pre><code>class Node(object):\n\n    def __init__(self, value=None, prev=None, next=None):\n        self.value = value\n        self.prev = prev\n        self.next = next</code></pre><p>双链表要比单链表多了一个指向<code>prev</code>的指针，实现起来反而要比单链表要简单</p>\n<h3 id=\"init\">__init__<a href=\"2019/08/26/双链表#init\"></a></h3><p>下面定义了一个<code>CircleList</code>类，初始化了第一个节点 <code>self.root</code>,然后让<code>root</code>节点的<code>prev</code><br>和<code>next</code>都指向自己，形成了一个环，后面在往上加的时候，依然在这个初始环通过重新断链再结合</p>\n<pre><code>class CircleList(object):\n    def __init__(self):\n        node = Node()\n        self.root = node\n        self.root.prev = node\n        self.root.next = node\n        self.length = 0</code></pre><h3 id=\"append\">append<a href=\"2019/08/26/双链表#append\"></a></h3><blockquote>\n<p>代码依然接着上面的写，依然在<code>CircleList</code>类中继续扩展</p>\n</blockquote>\n<p>要增加节点肯定要先new一个节点，在初始的环中<code>headnode</code>和<code>tailnode</code>都是指<br><code>root</code>，增加的过程就是让之前的环中的尾节点和新节点相连，新节点再和头节点相连，那么下次<br>访问<code>root.prev</code>就是新节点了，这个节点就加上了。</p>\n<pre><code>def append(self, value):\n    node = Node(value)\n    tailnode = self.root.prev\n    tailnode.next = node\n    node.prev = tailnode\n\n    self.root.prev = node\n    node.next = self.root\n    self.length += 1</code></pre><p>后面为了方便， 将<code>headnode</code>和<code>tailnode</code>单独写出来</p>\n<pre><code>def headnode(self):\n     return self.root.next\n\ndef tailnode(self):\n     return self.root.prev</code></pre><h3 id=\"输出节点\">输出节点<a href=\"2019/08/26/双链表#输出节点\"></a></h3><p>下面用生成器的方式iter每个节点,并重写了<code>__iter__</code>对数据进行输出，具体逻辑<br>如下开始有数值的节点就是<code>self.root.next</code>,然后不断的遍历链表直到，链表<br>走到<code>self.root</code> 中断遍历。这时输出的是节点， <code>__iter__</code>对每个节点的数值<br>进行输出</p>\n<pre><code>def iter_node(self):\n    flagenode = self.root.next\n    while flagenode is not self.root:\n        yield flagenode\n        flagenode = flagenode.next\n\ndef __iter__(self):\n    for node in self.iter_node():\n        yield node.value</code></pre><h3 id=\"find\">find<a href=\"2019/08/26/双链表#find\"></a></h3><p>下面对节点的查找是根据节点的索引进行查找，查找成功后返回该节点，上面实现了<br><code>iter_node</code> 这里直接复用了该方法，较为简单</p>\n<pre><code>def find(self, index):\n    flagindex = 0\n    if index &gt;=0 and index &lt;= self.length - 1:\n        for node in self.iter_node():\n            if flagindex == index:\n                return node\n            flagindex += 1\n    else:\n        raise Exception(&apos;out of range&apos;)</code></pre><h3 id=\"remove\">remove<a href=\"2019/08/26/双链表#remove\"></a></h3><p>查找完后，就可以将查找的节点，进行删除了，依然使用索引进行删除<br>查找到后将该节点的前后节点相连接，然后删除节点，<code>length--</code>这种常规操作了</p>\n<pre><code>def remove(self, index):\n    node = self.find(index)\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    del node\n    self.length -= 1</code></pre><h3 id=\"update\">update<a href=\"2019/08/26/双链表#update\"></a></h3><p><code>update</code>就更简单了，查找后直接赋值。</p>\n<pre><code>def update(self, index, value):\n       node = self.find(index)\n       node.value = value</code></pre><h3 id=\"reverse\">reverse<a href=\"2019/08/26/双链表#reverse\"></a></h3><p>对一个但链表进行反转其实没啥意思，因为不管从头还是从尾都可以遍历整张表<br>下面依然给出一个比较简单的实现</p>\n<pre><code>def reverse(self):\n  tailnode = self.tailnode()\n  while tailnode is not self.root:\n      yield tailnode.value\n      tailnode = tailnode.prev</code></pre>","prev":{"title":"python推导式","link":"2019/08/27/python推导式"},"next":{"title":"决策树","link":"2019/08/19/决策树"},"plink":"http://jccjd.top/2019/08/26/双链表/","copyright":{"link":"<a href=\"http://jccjd.top/2019/08/26/双链表/\" title=\"Python实现循环双链表\">http://jccjd.top/2019/08/26/双链表/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}