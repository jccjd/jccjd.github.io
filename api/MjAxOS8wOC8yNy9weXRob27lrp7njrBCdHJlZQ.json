{"title":"python实现单链表","date":"2019-08-26T16:00:00.000Z","link":"2019/08/27/python实现Btree","tags":["python","structure"],"categories":["structure"],"updated":"2019-10-24T02:02:35.319Z","content":"<h3 id=\"python实现Btree\">python实现Btree<a href=\"2019/08/27/python实现Btree#python实现Btree\"></a></h3><p>二叉树其实和双链表的结构很像，数据结构书里一般说链表是特殊的树，就是将一颗二叉树一条线下去只有左子节点或只有右子节点，当然最好还是看书详细了解<br>一下这里只做简单的实现。</p>\n<h3 id=\"构造节点\">构造节点<a href=\"2019/08/27/python实现Btree#构造节点\"></a></h3><p>树节点的构造需要一个值存value,一个左子节点<code>lchild</code>，一个右子节点<code>rchild</code>，如下这是个很简单的结构，直接可以看代码</p>\n<pre><code>class Node(object):\n    def __init__(self, value=None, lchild=None, rchild=None):\n        self.value = value\n        self.lchild = lchild\n        self.rchild = rchild</code></pre><h3 id=\"append-amp-遍历树\">append &amp; 遍历树<a href=\"2019/08/27/python实现Btree#append-amp-遍历树\"></a></h3><p>然后开始对这棵树增加节点，显然应该首先需要<code>new</code>一个节点，在初始化的时候定义了一个<code>self.root = None</code>，那么在第一次添加节点的时候，根据这个<br>标志，将第一个增加的节点作为<code>树的根</code>，假设为: <code>1</code></p>\n<p>当增加第二个节点的时候，情况就有点复杂了。首先要判断<code>root</code>节点的<code>lchild</code>是否为空，显然第一次添<br>加是为空的，假设第二个节点为: <code>2</code></p>\n<p>第三次添加时<code>rchild</code>也是空，这个也很容易加上,假设为: <code>3</code></p>\n<p>但当第四次要往上加节点的时候，就有问题了，往哪加啊，没地方加了，在加的话需要去遍历树，往最下面<br>一层的最左边的节点开始增加，也就是加到二节点的左子节点，</p>\n<p>那么树怎么遍历呢，这里引入了队列，用一个列表来模拟一个队列，我们将<code>self.root</code>放到队列中,要遍历的时候就将这个节点弹出，然后输出，第一个节点<br><code>self.root</code>在来判断<code>root</code>节点是否有左子节点,和右子节点(刚才我们加了两个元素在跟节点下所以一定是有的)<br>如果有将其加入到队列中，<strong>注意</strong>这个顺序一定是<code>先左子节点</code>后<code>右子节点的</code>，这个时候队列里有两个节点<code>[2, 3]</code>(这里放的是节点，输出时输出节点的<br>值，这里用<code>2,3</code>代替一下)<br>当再次弹出的时候就是弹出第二个节点输出也就是<code>2</code>，然后判断<code>2</code>是否有<code>lchild</code> or <code>rchild</code> 这里显然没有，然后去弹出<code>3</code>节点去输出值为3，依然判<br>是否有<code>lchild</code> or <code>rchild</code>，这时队列为空了这个树也遍历完了，那么我们增加的约束条件就是当队空时退出循环。</p>\n<pre><code>def breadth_order(self):\n    queue = [self.root]\n\n    while queue:\n        curnode = queue.pop(0)\n        print(curnode.value)\n        if curnode.lchild is not None:\n            queue.append(curnode.lchild)\n\n        if curnode.rchild is not None:\n            queue.append(curnode.rchild)</code></pre><p>那么可以遍历了，就可以添加节点了，在遍历的时候不做输出了，如果当前节点的<code>lchild</code>或<code>rchild</code>为空时，这正是我们想要的直接加上去即可，如果不为空<br>则像上面遍历的一样将当前节点存到队列当中，下一轮弹出的时候在为其做判断，直到队列中没有元素的时候停止循环。还是有点绕的。</p>\n<pre><code>def append(self, value):\n   node = Node(value)\n   if self.root is None:\n       self.root = node\n       return\n   queue = [self.root]\n   while queue:\n\n       curnode = queue.pop(0)\n       if curnode.lchild is  None:\n           curnode.lchild = node\n           return\n       else:\n           queue.append(curnode.lchild)\n\n\n       if curnode.rchild is None:\n           curnode.rchild = node\n           return\n       else:\n           queue.append(curnode.rchild)</code></pre><h3 id=\"广度优先搜素\">广度优先搜素<a href=\"2019/08/27/python实现Btree#广度优先搜素\"></a></h3><p>上面的遍历其实就是二叉树的广度优先搜索，可以看到在增加元素的时候用到了，所以显然，当用广度优先搜索的时候，就是将树的元素按照增加的顺序遍历了一遍<br>(为了文档的完整这里还是贴一下代码)</p>\n<pre><code>def breadth_order(self):\n queue = [self.root]\n\n while queue:\n     curnode = queue.pop(0)\n     print(curnode.value)\n     if curnode.lchild is not None:\n         queue.append(curnode.lchild)\n\n     if curnode.rchild is not None:\n         queue.append(curnode.rchild)</code></pre><h3 id=\"深度优先搜索\">深度优先搜索<a href=\"2019/08/27/python实现Btree#深度优先搜索\"></a></h3><p>深度优先有三种方式，先序遍历(DLR),中序遍历(LDR)，后序遍历(LRD)，然后分别的实现有非递归实现，和递归实现，递归实现代码简单，原理怎么说呢，看<br>个人理解吧，其实就算理解不了，还是能写出来的,这里直接给出代码，注意一点这里传入的值 node 是根结点，下面会给出测试代码</p>\n<pre><code># 先序遍历\ndef DLR_recursion(self, node):\n    if node is None:\n        return\n    print(node.value, end=&apos; &apos;)\n    self.DLR_recursion(node.lchild)\n    self.DLR_recursion(node.rchild)\n\n# 中序遍历\ndef LDR_recursion(self, node):\n    if node is None:\n        return\n    self.LDR_recursion(node.lchild)\n    print(node.value, end=&apos; &apos;)\n\n    self.LDR_recursion(node.rchild)\n\n# 后序遍历\ndef LRD_recursion(self, node):\n    if node is None:\n        return\n    self.DLR_recursion(node.lchild)\n    self.DLR_recursion(node.rchild)\n    print(node.value, end=&apos; &apos;)</code></pre><h4 id=\"DLR-非递归遍历\">DLR-非递归遍历<a href=\"2019/08/27/python实现Btree#DLR-非递归遍历\"></a></h4><p>非递归的先序遍历，其实现过程和深度优先遍历很相似，这里用到了栈去存取每个结点，可以参考深度优先的实现方式，用列表来模拟栈，这里的退出循环的条件是<br>当前节点和栈同时为空，带着空栈和根节点进入循环，然后遍历节点。</p>\n<blockquote>\n<p>假设一棵二叉树顺序存入<code>1-7</code></p>\n</blockquote>\n<pre><code>          1\n        /   \\\n       2     3\n     /  \\   /  \\\n    4    5 6    7\n\ndef DLR_no_recursive(self):\n  stack = []\n  curnode = self.root\n  while curnode or stack:\n      while curnode:\n          print(curnode.value, end=&apos; &apos;)\n          stack.append(curnode)\n          curnode = curnode.lchild\n      curnode = stack.pop()\n      curnode = curnode.rchild</code></pre><p>遍历第一个节点<code>1</code> 输出当前节点的值<code>1</code>，将当前节点压栈，当前节点左子节点<code>2</code> 成为当前节点，直到将左子节点遍历完，</p>\n<pre><code>这时得到打印`[1, 2, 4]` 压入栈中的节点也是`[1, 2, 4]`，跳出小循环\n\n弹出元素4,4的右子节点为空构不成进入小循环的条件       stack: [1, 2]\n弹出2, 2的右子节点为5进入小循环,                   stack: [1]\n将5压入栈中,5无子节点跳出循环                      stack: [1, 5]  print: `[1, 2, 4, 5]`\n弹出5,5的右子节点为空进入不了小循环,                stack: [1]\n弹出1，该节点存在左子节点3,进入循环将3压入栈中        stack: [3]     print: `[1, 2, 4, 5, 3]`，\n3也有左子节点6,输出6将6后在压入栈中，               stack: [3 ,6]  print: `[1, 2, 4, 5, 3, 6]` \n6无左子节点出循环，弹出6,6无子节点，                stack: [3]\n弹出3,3存在右子节点7,7进入循环输入7,                stack: [7]     print: `[1, 2, 4, 5, 3, 6, 7]`\n7无子结点跳出循环再弹出7，此时栈空，7无右子节点,结点也为空，跳出大循环，遍历结束。</code></pre><p>过程就是这么个过程，主要就是借助一个栈，进行节点的交换，根据先序遍历的规则来选择输出的时机。那么这是一个非递归实现先<br>序遍历的过程.</p>\n<h3 id=\"LDR\">LDR<a href=\"2019/08/27/python实现Btree#LDR\"></a></h3><p>下面的中序遍历和这个代码是一样的只是输出的时机不相同,中序遍历的时候是将每次弹出的节点进行输出，即可以得到中序遍历的过<br>程，</p>\n<pre><code>def LDR_no_recursive(self):\n    stack = []\n    curnode = self.root\n    stack_shadow = []\n    while  curnode or stack:\n        while curnode:\n            stack.append(curnode)\n            curnode = curnode.lchild\n        curnode = stack.pop()\n        print(curnode.value, end=&apos; &apos;)\n        curnode = curnode.rchild</code></pre><h3 id=\"LRD\">LRD<a href=\"2019/08/27/python实现Btree#LRD\"></a></h3><p>后续遍历，首先对一棵树进行后序遍历，将一棵树以根节点为轴进行反转</p>\n<pre><code>              |\n              1                         1\n            / | \\                     /   \\\n           2  |  3                   3     2\n         /  \\ | /  \\               /  \\   /  \\\n        4    5|6    7             7    6 5    4   \n              |\n后序：4 5 2 6 7 3 1             先序: 1 3 7 6 2 5 4</code></pre><p>可以看到反转后的先序序列是原树的后序序列的反序，那么有了这个特征，在遍历的时候从右子节点开始遍历，遍历事不进行输<br>了，在拿一个堆栈将元素存起来，最后将将其反序输出,代码的结构和上面依然保持一致，增加了一个列表和一个输出，而不是直接<br>打印，最后输出反序</p>\n<pre><code>def LRD_no_recursive(self):\n    stack = []\n    stack_shadow = []\n    curnode = self.root\n    while curnode or stack:\n        while curnode:\n            stack.append(curnode)\n            stack_shadow.append(curnode)\n            curnode = curnode.rchild\n        curnode = stack.pop()\n        curnode = curnode.lchild\n    return stack_shadow[::-1]</code></pre><p>以上二叉树的实现和其遍历的过程全部代码如下</p>\n<blockquote>\n<p><a href=\"https://github.com/jccjd/structur_algorithm\" target=\"_blank\" rel=\"noopener\">https://github.com/jccjd/structur_algorithm</a></p>\n</blockquote>\n","prev":{"title":"再议三次握手","link":"2019/09/13/再议三次握手和四次挥手"},"plink":"http://jccjd.top/2019/08/27/python实现Btree/","reward":true,"copyright":{"author":"Jccjd","link":"<a href=\"http://jccjd.top/2019/08/27/python实现Btree/\" title=\"python实现单链表\">http://jccjd.top/2019/08/27/python实现Btree/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"August 27, 2019","updated":"October 24, 2019"}}