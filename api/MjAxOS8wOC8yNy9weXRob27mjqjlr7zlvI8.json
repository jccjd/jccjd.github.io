{"title":"python推导式","date":"2019-08-26T16:00:00.000Z","link":"2019/08/27/python推导式","tags":["Python"],"categories":["Python"],"updated":"2019-10-25T07:43:47.171Z","content":"<h4 id=\"推导式-comprehensions\">推导式(comprehensions)<a href=\"2019/08/27/python推导式#推导式-comprehensions\"></a></h4><p>推导式又称解析式，是Python的一种独特特性。推导式可以从一个数据序列构建另一个新的数据序列的结构体。共有三种推导式</p>\n<ol>\n<li>list</li>\n<li>dict</li>\n<li>set<h4 id=\"列表推导式\"><a href=\"2019/08/27/python推导式#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h4>使用[]生成list</li>\n</ol>\n<p>基本格式：</p>\n<pre><code>list = [i for i in range(30) if i%3 is 0]\n应该只允许一个变量 i,将 i 从 迭代器对象rang(30)中取出\n然后对i进行判断 最后返回i   \n\ndef squared(x):\n    return x*x\nnewlist = [squared(x) for x in range(20) if i%3 is 0]\n最后返回值可以进行函数处理</code></pre><p>该方法返回的是一个数列，当要生成的数非常多的时候，占用空间将非常大<br>存在一定的问题，下面可以用生成器推导式可以解决这个问题</p>\n<h4 id=\"生成器推导式-generator\">生成器推导式(generator)<a href=\"2019/08/27/python推导式#生成器推导式-generator\"></a></h4><p>生成器推导式只需将[] 变为()</p>\n<pre><code>generator = (i ** 2 for i in range(10) if i % 2 is 0)\n&lt;generator object &lt;genexpr&gt; at 0x0000028A8FB35E58&gt;</code></pre><p>该generator 是一个生成器对象，生成器本质就是迭代器，那么该对象就可以取多少用多少，而不用一次生成全部数据。</p>\n<h4 id=\"字典推导式\">字典推导式<a href=\"2019/08/27/python推导式#字典推导式\"></a></h4><p>字典推导式将列表推导式的中括号改为大括号，下面将mydict字典的小写关键字提取出来</p>\n<pre><code>mydict = {&apos;a&apos;:10,&apos;b&apos;:34,&apos;c&apos;: 90,&apos;A&apos;:10}\nmydict_frequency = {\n     k.lower():mydict.get(k.lower()) for k in mydict.keys()\n}</code></pre><h4 id=\"创建字典的方法\">创建字典的方法<a href=\"2019/08/27/python推导式#创建字典的方法\"></a></h4><h5 id=\"直接创建\">直接创建<a href=\"2019/08/27/python推导式#直接创建\"></a></h5><pre><code>dict = {&apos;name&apos;:&apos;name&apos;,&apos;port&apos;:100 }</code></pre><h5 id=\"工厂方法\">工厂方法<a href=\"2019/08/27/python推导式#工厂方法\"></a></h5><pre><code>items = [(&apos;name&apos;,&apos;earth&apos;),(&apos;port&apos;,&apos;80)]\ndict = dict(items)</code></pre><h5 id=\"fromkeys-方法\">fromkeys()方法<a href=\"2019/08/27/python推导式#fromkeys-方法\"></a></h5><pre><code>my_dict = {}.fromkeys((&apos;x&apos;,&apos;y&apos;),12))</code></pre><h4 id=\"合并两个有序列表\">合并两个有序列表<a href=\"2019/08/27/python推导式#合并两个有序列表\"></a></h4><pre><code>#合并两个有序列表\ndef link_two_list(l1,l2,tmp):\n    if len(l1) == 0 or len(l2) == 0:\n        tmp.extend(l1)\n        tmp.extend(l2)\n        return tmp\n    else:\n        if l1[0] &lt; l2[0]:\n            tmp.append(l1[0])\n            del l1[0]\n        else:\n            tmp.append(l2[0])\n            del l2[0]\n        return link_two_list(l1,l2,tmp)    </code></pre><p>思路：对比两个列表的第一个元素，将小的加入到新列表中，然后删除该元素，然后递归比较，每次都是对比第一个元素<br>若果有个比较列表比较短，当L2还有元素时L1已经提前清空，那么直接将<br>l2的剩余元素直接加入到tmp中，直接返回tmp</p>\n","prev":{"title":"python实现Btree","link":"2019/08/30/python实现Btree"},"next":{"title":"Python实现循环双链表","link":"2019/08/26/双链表"},"plink":"http://jccjd.top/2019/08/27/python推导式/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/08/27/python推导式/\" title=\"python推导式\">http://jccjd.top/2019/08/27/python推导式/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}