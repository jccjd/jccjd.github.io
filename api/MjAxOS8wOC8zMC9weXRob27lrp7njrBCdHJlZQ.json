{"title":"python实现Btree","date":"2019-08-29T16:00:00.000Z","date_formatted":{"ll":"Aug 30, 2019","L":"08/30/2019","MM-DD":"08-30"},"link":"2019/08/30/python实现Btree","tags":["structure"],"categories":["structure"],"updated":"2020-02-09T08:37:20.000Z","content":"<h3 id=\"python实现btree\">python实现Btree<a href=\"#python实现btree\" title=\"python实现Btree\"></a></h3><p>二叉树其实和双链表的结构很像，数据结构书里一般说链表是特殊的树，就是将一颗二叉树一条线下去只有左子节点或只有右子节点，当然最好还是看书详细了解<br>一下这里只做简单的实现。</p>\n<h3 id=\"构造节点\">构造节点<a href=\"#构造节点\" title=\"构造节点\"></a></h3><p>树节点的构造需要一个值存value,一个左子节点<code>lchild</code>，一个右子节点<code>rchild</code>，如下这是个很简单的结构，直接可以看代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value=None, lchild=None, rchild=None)</span>:</span></span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\">        self.lchild = lchild</span><br><span class=\"line\">        self.rchild = rchild</span><br></pre></td></tr></table></figure><h3 id=\"append-amp-遍历树\">append &amp; 遍历树<a href=\"#append-amp-遍历树\" title=\"append &amp; 遍历树\"></a></h3><p>然后开始对这棵树增加节点，显然应该首先需要<code>new</code>一个节点，在初始化的时候定义了一个<code>self.root = None</code>，那么在第一次添加节点的时候，根据这个<br>标志，将第一个增加的节点作为<code>树的根</code>，假设为: <code>1</code></p>\n<p>当增加第二个节点的时候，情况就有点复杂了。首先要判断<code>root</code>节点的<code>lchild</code>是否为空，显然第一次添<br>加是为空的，假设第二个节点为: <code>2</code></p>\n<p>第三次添加时<code>rchild</code>也是空，这个也很容易加上,假设为: <code>3</code></p>\n<p>但当第四次要往上加节点的时候，就有问题了，往哪加啊，没地方加了，在加的话需要去遍历树，往最下面<br>一层的最左边的节点开始增加，也就是加到二节点的左子节点，</p>\n<p>那么树怎么遍历呢，这里引入了队列，用一个列表来模拟一个队列，我们将<code>self.root</code>放到队列中,要遍历的时候就将这个节点弹出，然后输出，第一个节点<br><code>self.root</code>在来判断<code>root</code>节点是否有左子节点,和右子节点(刚才我们加了两个元素在跟节点下所以一定是有的)<br>如果有将其加入到队列中，<strong>注意</strong>这个顺序一定是<code>先左子节点</code>后<code>右子节点的</code>，这个时候队列里有两个节点<code>[2, 3]</code>(这里放的是节点，输出时输出节点的<br>值，这里用<code>2,3</code>代替一下)<br>当再次弹出的时候就是弹出第二个节点输出也就是<code>2</code>，然后判断<code>2</code>是否有<code>lchild</code> or <code>rchild</code> 这里显然没有，然后去弹出<code>3</code>节点去输出值为3，依然判<br>是否有<code>lchild</code> or <code>rchild</code>，这时队列为空了这个树也遍历完了，那么我们增加的约束条件就是当队空时退出循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">breadth_order</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    queue = [self.root]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">        curnode = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">        print(curnode.value)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> curnode.lchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            queue.append(curnode.lchild)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> curnode.rchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            queue.append(curnode.rchild)</span><br></pre></td></tr></table></figure><p>那么可以遍历了，就可以添加节点了，在遍历的时候不做输出了，如果当前节点的<code>lchild</code>或<code>rchild</code>为空时，这正是我们想要的直接加上去即可，如果不为空<br>则像上面遍历的一样将当前节点存到队列当中，下一轮弹出的时候在为其做判断，直到队列中没有元素的时候停止循环。还是有点绕的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">append</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">   node = Node(value)</span><br><span class=\"line\">   <span class=\"keyword\">if</span> self.root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">       self.root = node</span><br><span class=\"line\">       <span class=\"keyword\">return</span></span><br><span class=\"line\">   queue = [self.root]</span><br><span class=\"line\">   <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\"></span><br><span class=\"line\">       curnode = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">       <span class=\"keyword\">if</span> curnode.lchild <span class=\"keyword\">is</span>  <span class=\"literal\">None</span>:</span><br><span class=\"line\">           curnode.lchild = node</span><br><span class=\"line\">           <span class=\"keyword\">return</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">           queue.append(curnode.lchild)</span><br></pre></td></tr></table></figure><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> curnode.rchild <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    curnode.rchild = node</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    queue.append(curnode.rchild)</span><br></pre></td></tr></table></figure><h3 id=\"广度优先搜素\">广度优先搜素<a href=\"#广度优先搜素\" title=\"广度优先搜素\"></a></h3><p>上面的遍历其实就是二叉树的广度优先搜索，可以看到在增加元素的时候用到了，所以显然，当用广度优先搜索的时候，就是将树的元素按照增加的顺序遍历了一遍<br>(为了文档的完整这里还是贴一下代码)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">breadth_order</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"> queue = [self.root]</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">while</span> queue:</span><br><span class=\"line\">     curnode = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">     print(curnode.value)</span><br><span class=\"line\">     <span class=\"keyword\">if</span> curnode.lchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">         queue.append(curnode.lchild)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> curnode.rchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">         queue.append(curnode.rchild)</span><br></pre></td></tr></table></figure><h3 id=\"深度优先搜索\">深度优先搜索<a href=\"#深度优先搜索\" title=\"深度优先搜索\"></a></h3><p>深度优先有三种方式，先序遍历(DLR),中序遍历(LDR)，后序遍历(LRD)，然后分别的实现有非递归实现，和递归实现，递归实现代码简单，原理怎么说呢，看<br>个人理解吧，其实就算理解不了，还是能写出来的,这里直接给出代码，注意一点这里传入的值 node 是根结点，下面会给出测试代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">DLR_recursion</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    print(node.value, end=<span class=\"string\">' '</span>)</span><br><span class=\"line\">    self.DLR_recursion(node.lchild)</span><br><span class=\"line\">    self.DLR_recursion(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 中序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LDR_recursion</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    self.LDR_recursion(node.lchild)</span><br><span class=\"line\">    print(node.value, end=<span class=\"string\">' '</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    self.LDR_recursion(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LRD_recursion</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    self.DLR_recursion(node.lchild)</span><br><span class=\"line\">    self.DLR_recursion(node.rchild)</span><br><span class=\"line\">    print(node.value, end=<span class=\"string\">' '</span>)</span><br></pre></td></tr></table></figure><h4 id=\"dlr-非递归遍历\">DLR-非递归遍历<a href=\"#dlr-非递归遍历\" title=\"DLR-非递归遍历\"></a></h4><p>非递归的先序遍历，其实现过程和深度优先遍历很相似，这里用到了栈去存取每个结点，可以参考深度优先的实现方式，用列表来模拟栈，这里的退出循环的条件是<br>当前节点和栈同时为空，带着空栈和根节点进入循环，然后遍历节点。</p>\n<blockquote>\n<p>假设一棵二叉树顺序存入<code>1-7</code></p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"number\">1</span></span><br><span class=\"line\">        /   \\</span><br><span class=\"line\">       <span class=\"number\">2</span>     <span class=\"number\">3</span></span><br><span class=\"line\">     /  \\   /  \\</span><br><span class=\"line\">    <span class=\"number\">4</span>    <span class=\"number\">5</span> <span class=\"number\">6</span>    <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">DLR_no_recursive</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">  stack = []</span><br><span class=\"line\">  curnode = self.root</span><br><span class=\"line\">  <span class=\"keyword\">while</span> curnode <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">      <span class=\"keyword\">while</span> curnode:</span><br><span class=\"line\">          print(curnode.value, end=<span class=\"string\">' '</span>)</span><br><span class=\"line\">          stack.append(curnode)</span><br><span class=\"line\">          curnode = curnode.lchild</span><br><span class=\"line\">      curnode = stack.pop()</span><br><span class=\"line\">      curnode = curnode.rchild</span><br></pre></td></tr></table></figure><p>遍历第一个节点<code>1</code> 输出当前节点的值<code>1</code>，将当前节点压栈，当前节点左子节点<code>2</code> 成为当前节点，直到将左子节点遍历完，</p>\n<pre><code>这时得到打印`[1, 2, 4]` 压入栈中的节点也是`[1, 2, 4]`，跳出小循环\n\n弹出元素4,4的右子节点为空构不成进入小循环的条件       stack: [1, 2]\n弹出2, 2的右子节点为5进入小循环,                   stack: [1]\n将5压入栈中,5无子节点跳出循环                      stack: [1, 5]  print: `[1, 2, 4, 5]`\n弹出5,5的右子节点为空进入不了小循环,                stack: [1]\n弹出1，该节点存在左子节点3,进入循环将3压入栈中        stack: [3]     print: `[1, 2, 4, 5, 3]`，\n3也有左子节点6,输出6将6后在压入栈中，               stack: [3 ,6]  print: `[1, 2, 4, 5, 3, 6]`\n6无左子节点出循环，弹出6,6无子节点，                stack: [3]\n弹出3,3存在右子节点7,7进入循环输入7,                stack: [7]     print: `[1, 2, 4, 5, 3, 6, 7]`\n7无子结点跳出循环再弹出7，此时栈空，7无右子节点,结点也为空，跳出大循环，遍历结束。</code></pre><p>过程就是这么个过程，主要就是借助一个栈，进行节点的交换，根据先序遍历的规则来选择输出的时机。那么这是一个非递归实现先<br>序遍历的过程.</p>\n<h3 id=\"ldr\">LDR<a href=\"#ldr\" title=\"LDR\"></a></h3><p>下面的中序遍历和这个代码是一样的只是输出的时机不相同,中序遍历的时候是将每次弹出的节点进行输出，即可以得到中序遍历的过<br>程，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LDR_no_recursive</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    curnode = self.root</span><br><span class=\"line\">    stack_shadow = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span>  curnode <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> curnode:</span><br><span class=\"line\">            stack.append(curnode)</span><br><span class=\"line\">            curnode = curnode.lchild</span><br><span class=\"line\">        curnode = stack.pop()</span><br><span class=\"line\">        print(curnode.value, end=<span class=\"string\">' '</span>)</span><br><span class=\"line\">        curnode = curnode.rchild</span><br></pre></td></tr></table></figure><h3 id=\"lrd\">LRD<a href=\"#lrd\" title=\"LRD\"></a></h3><p>后续遍历，首先对一棵树进行后序遍历，将一棵树以根节点为轴进行反转</p>\n<pre><code>              |\n              1                         1\n            / | \\                     /   \\\n           2  |  3                   3     2\n         /  \\ | /  \\               /  \\   /  \\\n        4    5|6    7             7    6 5    4   \n              |\n后序：4 5 2 6 7 3 1             先序: 1 3 7 6 2 5 4</code></pre><p>可以看到反转后的先序序列是原树的后序序列的反序，那么有了这个特征，在遍历的时候从右子节点开始遍历，遍历事不进行输<br>了，在拿一个堆栈将元素存起来，最后将将其反序输出,代码的结构和上面依然保持一致，增加了一个列表和一个输出，而不是直接<br>打印，最后输出反序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">LRD_no_recursive</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    stack = []</span><br><span class=\"line\">    stack_shadow = []</span><br><span class=\"line\">    curnode = self.root</span><br><span class=\"line\">    <span class=\"keyword\">while</span> curnode <span class=\"keyword\">or</span> stack:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> curnode:</span><br><span class=\"line\">            stack.append(curnode)</span><br><span class=\"line\">            stack_shadow.append(curnode)</span><br><span class=\"line\">            curnode = curnode.rchild</span><br><span class=\"line\">        curnode = stack.pop()</span><br><span class=\"line\">        curnode = curnode.lchild</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack_shadow[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure><p>以上二叉树的实现和其遍历的过程全部代码如下</p>\n<blockquote>\n<p><a href=\"https://github.com/jccjd/structur_algorithm\" target=\"_blank\">https://github.com/jccjd/structur_algorithm</a></p>\n</blockquote>\n","prev":{"title":"docker doc","link":"2019/09/01/docker doc"},"next":{"title":"python推导式","link":"2019/08/27/python推导式"},"plink":"http://yoursite.com/2019/08/30/python实现Btree/","toc":[{"id":"python实现btree","title":"python实现Btree","index":"1"},{"id":"构造节点","title":"构造节点","index":"2"},{"id":"append-amp-遍历树","title":"append &amp; 遍历树","index":"3"},{"id":"广度优先搜素","title":"广度优先搜素","index":"4"},{"id":"深度优先搜索","title":"深度优先搜索","index":"5","children":[{"id":"dlr-非递归遍历","title":"DLR-非递归遍历","index":"5.1"}]},{"id":"ldr","title":"LDR","index":"6"},{"id":"lrd","title":"LRD","index":"7"}],"copyright":{"link":"<a href=\"http://yoursite.com/2019/08/30/python实现Btree/\" title=\"python实现Btree\">http://yoursite.com/2019/08/30/python实现Btree/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}