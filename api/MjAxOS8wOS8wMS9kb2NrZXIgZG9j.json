{"title":"docker doc","date":"2019-08-31T16:00:00.000Z","link":"2019/09/01/docker doc","tags":["docker","docs"],"updated":"2019-10-25T07:30:33.985Z","content":"<h3 id=\"what-is-Docker\">what is Docker<a href=\"2019/09/01/docker doc#what-is-Docker\"></a></h3><pre><code>Docker是一款针对程序开发人员和系统管理员来开发、部署、运行应用的一款虚拟化平台。\nDocker 可以让你像使用集装箱一样快速的组合成应用，并且可以像运输标准集装箱一样，\n尽可能的屏蔽代码层面的差异。Docker 会尽可能的缩短从代码测试到产品部署的时间。</code></pre><p>docker是一种虚拟机技术,于传统的虚拟机技术,不同docker是直接使用宿主的的内核,他没有对硬件进行<br>虚拟,因此从此方面将要虚拟设备跟轻便.</p>\n<p>它是一种对开发而言更为适合的虚拟方式, 在开发过程中 docker可以提供除了内核外完成的开发运行环境,可以保证应用环境的一致性,解决了历史性难题<code>这代码在我的电脑上没问题,在你电脑上就有bug了</code></p>\n<p><strong>docker 要求linux的内核要在3.10以上,安装前要查看linux的内核版本<code>uname -r</code></strong></p>\n<h3 id=\"docker的三个基本概念\">docker的三个基本概念<a href=\"2019/09/01/docker doc#docker的三个基本概念\"></a></h3><ul>\n<li>Image</li>\n<li>Container</li>\n<li>Repository</li>\n</ul>\n<h3 id=\"Image\"><em>Image</em><a href=\"2019/09/01/docker doc#Image\"></a></h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<h3 id=\"Container\"><em>Container</em><a href=\"2019/09/01/docker doc#Container\"></a></h3><p>容器和镜像和的关系相当于类和实例的关系,容器是镜像运行的实体.</p>\n<p><strong>如果要删除某个镜像, 需要先删除该镜像的创建出的所有容器, 因为容器在运行时会有守护进程</strong></p>\n<h3 id=\"Repository\"><em>Repository</em><a href=\"2019/09/01/docker doc#Repository\"></a></h3><h3 id=\"docker安装\">docker安装<a href=\"2019/09/01/docker doc#docker安装\"></a></h3><p>docker可以直接使用<code>pip</code>进行安装</p>\n<pre><code>sudo pip install -U docker-compose</code></pre><h3 id=\"常用命令\">常用命令<a href=\"2019/09/01/docker doc#常用命令\"></a></h3><h4 id=\"启动-关闭-重启-docker\">启动/关闭/重启/docker<a href=\"2019/09/01/docker doc#启动-关闭-重启-docker\"></a></h4><pre><code>sudo service docker start/stop/restart</code></pre><h4 id=\"镜像列表\">镜像列表<a href=\"2019/09/01/docker doc#镜像列表\"></a></h4><pre><code>sudo docker image ls</code></pre><h4 id=\"从仓库获取镜像\">从仓库获取镜像<a href=\"2019/09/01/docker doc#从仓库获取镜像\"></a></h4><pre><code>sudo docker pull imagename</code></pre><h4 id=\"查看镜像的container\">查看镜像的container<a href=\"2019/09/01/docker doc#查看镜像的container\"></a></h4><pre><code>docker ps -a</code></pre><h4 id=\"删除container\">删除container<a href=\"2019/09/01/docker doc#删除container\"></a></h4><pre><code>docker rm containerid</code></pre><h4 id=\"运行container\">运行container<a href=\"2019/09/01/docker doc#运行container\"></a></h4><pre><code>docker start Containerid</code></pre><h4 id=\"删除镜像\">删除镜像<a href=\"2019/09/01/docker doc#删除镜像\"></a></h4><pre><code>sudo docker image rm imagename/imageid</code></pre><p>在删除镜像之前要先停止该镜像的容器</p>\n<h3 id=\"启动容器\">启动容器<a href=\"2019/09/01/docker doc#启动容器\"></a></h3><h4 id=\"交互式容器\">交互式容器<a href=\"2019/09/01/docker doc#交互式容器\"></a></h4><pre><code>sudo docker run -it --name=name1 imagename cmd</code></pre><h4 id=\"守护式容器\">守护式容器<a href=\"2019/09/01/docker doc#守护式容器\"></a></h4><pre><code>sudo docker run -dit --name=ubuntu1 ubuntu cmd\n\n* -i 表示以《交互模式》运行容器。\n* -t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端\n* --name 为创建的容器命名。\n* -v 表示目录映射关系，即宿主机目录:容器中目录。注意:最好做目录映射，在宿主机上做修改，然后共享到容器上。\n* -d 会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器)。\n* -p 表示端口映射，即宿主机端口:容器中端口。\n* --network=host 表示将主机的网络环境映射到容器中，使容器的网络与主机相同。</code></pre><h3 id=\"进入容器\">进入容器<a href=\"2019/09/01/docker doc#进入容器\"></a></h3><pre><code>sudo docker exec -it Containerid/name cmd</code></pre><h4 id=\"将端口映射到主机\">将端口映射到主机<a href=\"2019/09/01/docker doc#将端口映射到主机\"></a></h4><p>docker run -d -P training/webapp python app.py</p>\n<h4 id=\"打印日志\">打印日志<a href=\"2019/09/01/docker doc#打印日志\"></a></h4><p>docker logs -f bf08b7</p>\n<h3 id=\"docker-compose\">docker-compose<a href=\"2019/09/01/docker doc#docker-compose\"></a></h3><p>直接可以使用 pip安装</p>\n<pre><code>sudo pip install -U docker-compose\n\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><h3 id=\"将容器做成镜像\">将容器做成镜像<a href=\"2019/09/01/docker doc#将容器做成镜像\"></a></h3><pre><code>docker commit containername/id imagename</code></pre><h3 id=\"打包镜像\">打包镜像<a href=\"2019/09/01/docker doc#打包镜像\"></a></h3><pre><code>docker save -o filename imageid</code></pre><h3 id=\"镜像重新装载到-docker中\">镜像重新装载到 docker中<a href=\"2019/09/01/docker doc#镜像重新装载到-docker中\"></a></h3><pre><code>docker load -i localpath/filename</code></pre><h3 id=\"FastDFS的Docker配置\">FastDFS的Docker配置<a href=\"2019/09/01/docker doc#FastDFS的Docker配置\"></a></h3>","prev":{"title":"WSGI","link":"2019/09/03/WSGI"},"next":{"title":"python实现Btree","link":"2019/08/30/python实现Btree"},"plink":"http://jccjd.top/2019/09/01/docker doc/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/09/01/docker doc/\" title=\"docker doc\">http://jccjd.top/2019/09/01/docker doc/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}