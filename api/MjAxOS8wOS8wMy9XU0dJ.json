{"title":"WSGI","date":"2019-09-02T16:00:00.000Z","link":"2019/09/03/WSGI","tags":["wsgi"],"updated":"2019-10-25T08:27:28.392Z","content":"<h3 id=\"web服务器和web框架\">web服务器和web框架<a href=\"2019/09/03/WSGI#web服务器和web框架\"></a></h3><p>web服务器即是用来接受客户端请求，建立连接的程序， web框架则是用来处理业<br>务逻辑的，比如可以有很多的服务器<code>nginx</code>，<code>apche</code>，uWSGI也可以有很多的框<br>架，django，flask，那这些东西如何搭配就会有问题，那么这个问题的解决方就是<br>WSGI。</p>\n<p>所以WSGI 就如其名是一个网关接口，提供服务器和框架之间数据转发的一<br>个接口，要通过这个接口当然就需要一定的规范。下面就是这种规范的具体内容</p>\n<h3 id=\"WSGI\">WSGI<a href=\"2019/09/03/WSGI#WSGI\"></a></h3><p>在PEP 333 中的摘要给出，</p>\n<blockquote>\n<p>This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.</p>\n</blockquote>\n<p>也就是说 WSGI 是指定Web服务器与Python Web应用程序或框架之间的标准接口，<br>以促进Web应用程序在各种Web服务器之间的可移植性。</p>\n<p>而且由于早期的框架和服务器并不支持WSGI，而为了推广WSGI, WSGI<br>就必须简单易于实现，使得框架作者的实现成本降低。</p>\n<h3 id=\"django-中的WSGI\">django 中的WSGI<a href=\"2019/09/03/WSGI#django-中的WSGI\"></a></h3><p>在django中的 wsgi.py 可以看到它是通过get_application()返回WSIGHandlers()<br>而在WSIGHandlers中实现了<code>__call__</code>使得其被调用时返回<code>response</code>，</p>\n<p><strong>其中两个参数是必须的 <code>environ</code>, <code>start_response</code></strong></p>\n<pre><code>class WSGIHandler(base.BaseHandler):\n    request_class = WSGIRequest\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.load_middleware()\n\n    def __call__(self, environ, start_response):\n        set_script_prefix(get_script_name(environ))\n        signals.request_started.send(sender=self.__class__, environ=environ)\n        request = self.request_class(environ)\n        response = self.get_response(request)\n\n        response._handler_class = self.__class__\n\n        status = &apos;%d %s&apos; % (response.status_code, response.reason_phrase)\n        response_headers = list(response.items())\n        for c in response.cookies.values():\n            response_headers.append((&apos;Set-Cookie&apos;, c.output(header=&apos;&apos;)))\n        start_response(status, response_headers)\n        if getattr(response, &apos;file_to_stream&apos;, None) is not None and environ.get(&apos;wsgi.file_wrapper&apos;):\n            response = environ[&apos;wsgi.file_wrapper&apos;](response.file_to_stream)\n        return response</code></pre><h4 id=\"WSGI应用端\">WSGI应用端<a href=\"2019/09/03/WSGI#WSGI应用端\"></a></h4><p>application 端的协议就是这样的，这个api只需要两个参数，可以看到是非<br>常简单的，上面是框架中的东西，<code>PEP 333</code>,中给出了一个更简单的 事例，下面<br>对该事例进行了修改</p>\n<pre><code>def simple_app(environ, start_response):\n    stdout = &quot;Hello world!&quot;\n    h = sorted(environ.items())\n    for k,v in h:\n        stdout += k + &apos;=&apos; + repr(v) + &quot;\\r\\n&quot;\n    print(start_response)\n    start_response(&quot;200 OK&quot;, [(&apos;Content-Type&apos;,&apos;text/plain; charset=utf-8&apos;)])\n    return [stdout.encode(&quot;utf-8&quot;)]</code></pre><p>上面的代码就算一个满足WSGI的Web应用程序，只要接收两个参数即可，看起来很<br>像是API，其实它的确可以是当作API来用的但是这是给框架开发者使用的，</p>\n<blockquote>\n<p>WSGI是面向框架、服务器开发者的工具，而不是为应用开发者直接提供支持的。</p>\n</blockquote>\n<h4 id=\"WSGI服务端\">WSGI服务端<a href=\"2019/09/03/WSGI#WSGI服务端\"></a></h4><p>下面通过标准库中的<code>wsgiref.simple_server</code> 来实现一个简单的服务器，开启之<br>后即可，通过网页访问本地端口8000得到请求</p>\n<pre><code>from wsgiref.simple_server import make_server\n\nhttpd = make_server(&apos;&apos;, 8000, simple_app)\nprint(&apos;Serving HTTP on port 8000...&apos;)\nhttpd.serve_forever()</code></pre><p>当从HTTP客户端收到一个请求，服务器就调用simple_app去做逻辑处理并返回处理<br>的结果集。</p>\n<h4 id=\"中间件\">中间件<a href=\"2019/09/03/WSGI#中间件\"></a></h4><p>中间件有着如下功能</p>\n<ul>\n<li>在重写environ之后，相应地根据目标URL把请求发到对应的应用对象。</li>\n<li>允许多个应用或者框架并行允许。</li>\n<li>通过网络来转发请求和相应，实现负载均衡和远程处理。</li>\n<li>对内容进行后续处理，比如应用XSL样式表</li>\n</ul>\n<p>在web服务器和应用程序之间存在着中间件，在的django中存在的中间件去处理请求<br>视图，响应，模板，和异常，层层的包裹而形成了中间件栈(middleware stack)</p>\n<pre><code>self._request_middleware = []\nself._view_middleware = []\nself._template_response_middleware = []\nself._response_middleware = []\nself._exception_middleware = []</code></pre><p>那么这些中间件在出入栈的过程中，中间件的位置就成立相对位置，对服务器他是<br>应用，对于应用则他是服务.</p>\n<h3 id=\"参考\">参考<a href=\"2019/09/03/WSGI#参考\"></a></h3><ul>\n<li><a href=\"https://www.python.org/dev/peps/pep-0333/\" target=\"_blank\" rel=\"noopener\">PEP 333 – Python Web Server Gateway Interface v1.0</a></li>\n<li><a href=\"http://www.hongweipeng.com/index.php/archives/1537/\" target=\"_blank\" rel=\"noopener\">hongweipeng</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760\" target=\"_blank\" rel=\"noopener\">liaoxuefeng</a></li>\n</ul>\n","prev":{"title":"Redis doc","link":"2019/09/13/Redis doc"},"next":{"title":"docker doc","link":"2019/09/01/docker doc"},"plink":"http://jccjd.top/2019/09/03/WSGI/","copyright":{"link":"<a href=\"http://jccjd.top/2019/09/03/WSGI/\" title=\"WSGI\">http://jccjd.top/2019/09/03/WSGI/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}