{"title":"WSGI","date":"2019-09-02T16:00:00.000Z","date_formatted":{"ll":"Sep 3, 2019","L":"09/03/2019","MM-DD":"09-03"},"link":"2019/09/03/WSGI","tags":["wsgi"],"updated":"2020-02-09T08:37:42.000Z","content":"<h3 id=\"web服务器和web框架\">web服务器和web框架<a href=\"#web服务器和web框架\" title=\"web服务器和web框架\"></a></h3><p>web服务器即是用来接受客户端请求，建立连接的程序， web框架则是用来处理业<br>务逻辑的，比如可以有很多的服务器<code>nginx</code>，<code>apche</code>，uWSGI也可以有很多的框<br>架，django，flask，那这些东西如何搭配就会有问题，那么这个问题的解决方就是<br>WSGI。</p>\n<p>所以WSGI 就如其名是一个网关接口，提供服务器和框架之间数据转发的一<br>个接口，要通过这个接口当然就需要一定的规范。下面就是这种规范的具体内容</p>\n<h3 id=\"wsgi\">WSGI<a href=\"#wsgi\" title=\"WSGI\"></a></h3><p>在PEP 333 中的摘要给出，</p>\n<blockquote>\n<p>This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.</p>\n</blockquote>\n<p>也就是说 WSGI 是指定Web服务器与Python Web应用程序或框架之间的标准接口，<br>以促进Web应用程序在各种Web服务器之间的可移植性。</p>\n<p>而且由于早期的框架和服务器并不支持WSGI，而为了推广WSGI, WSGI<br>就必须简单易于实现，使得框架作者的实现成本降低。</p>\n<h3 id=\"django-中的wsgi\">django 中的WSGI<a href=\"#django-中的wsgi\" title=\"django 中的WSGI\"></a></h3><p>在django中的 wsgi.py 可以看到它是通过get_application()返回WSIGHandlers()<br>而在WSIGHandlers中实现了<code>__call__</code>使得其被调用时返回<code>response</code>，</p>\n<p><strong>其中两个参数是必须的 <code>environ</code>, <code>start_response</code></strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WSGIHandler</span><span class=\"params\">(base.BaseHandler)</span>:</span></span><br><span class=\"line\">    request_class = WSGIRequest</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        super().__init__(*args, **kwargs)</span><br><span class=\"line\">        self.load_middleware()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, environ, start_response)</span>:</span></span><br><span class=\"line\">        set_script_prefix(get_script_name(environ))</span><br><span class=\"line\">        signals.request_started.send(sender=self.__class__, environ=environ)</span><br><span class=\"line\">        request = self.request_class(environ)</span><br><span class=\"line\">        response = self.get_response(request)</span><br><span class=\"line\"></span><br><span class=\"line\">        response._handler_class = self.__class__</span><br><span class=\"line\"></span><br><span class=\"line\">        status = <span class=\"string\">'%d %s'</span> % (response.status_code, response.reason_phrase)</span><br><span class=\"line\">        response_headers = list(response.items())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> response.cookies.values():</span><br><span class=\"line\">            response_headers.append((<span class=\"string\">'Set-Cookie'</span>, c.output(header=<span class=\"string\">''</span>)))</span><br><span class=\"line\">        start_response(status, response_headers)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> getattr(response, <span class=\"string\">'file_to_stream'</span>, <span class=\"literal\">None</span>) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> environ.get(<span class=\"string\">'wsgi.file_wrapper'</span>):</span><br><span class=\"line\">            response = environ[<span class=\"string\">'wsgi.file_wrapper'</span>](response.file_to_stream)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br></pre></td></tr></table></figure><h4 id=\"wsgi应用端\">WSGI应用端<a href=\"#wsgi应用端\" title=\"WSGI应用端\"></a></h4><p>application 端的协议就是这样的，这个api只需要两个参数，可以看到是非<br>常简单的，上面是框架中的东西，<code>PEP 333</code>,中给出了一个更简单的 事例，下面<br>对该事例进行了修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_app</span><span class=\"params\">(environ, start_response)</span>:</span></span><br><span class=\"line\">    stdout = <span class=\"string\">\"Hello world!\"</span></span><br><span class=\"line\">    h = sorted(environ.items())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> h:</span><br><span class=\"line\">        stdout += k + <span class=\"string\">'='</span> + repr(v) + <span class=\"string\">\"\\r\\n\"</span></span><br><span class=\"line\">    print(start_response)</span><br><span class=\"line\">    start_response(<span class=\"string\">\"200 OK\"</span>, [(<span class=\"string\">'Content-Type'</span>,<span class=\"string\">'text/plain; charset=utf-8'</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [stdout.encode(<span class=\"string\">\"utf-8\"</span>)]</span><br></pre></td></tr></table></figure><p>上面的代码就算一个满足WSGI的Web应用程序，只要接收两个参数即可，看起来很<br>像是API，其实它的确可以是当作API来用的但是这是给框架开发者使用的，</p>\n<blockquote>\n<p>WSGI是面向框架、服务器开发者的工具，而不是为应用开发者直接提供支持的。</p>\n</blockquote>\n<h4 id=\"wsgi服务端\">WSGI服务端<a href=\"#wsgi服务端\" title=\"WSGI服务端\"></a></h4><p>下面通过标准库中的<code>wsgiref.simple_server</code> 来实现一个简单的服务器，开启之<br>后即可，通过网页访问本地端口8000得到请求</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> wsgiref.simple_server <span class=\"keyword\">import</span> make_server</span><br><span class=\"line\"></span><br><span class=\"line\">httpd = make_server(<span class=\"string\">''</span>, <span class=\"number\">8000</span>, simple_app)</span><br><span class=\"line\">print(<span class=\"string\">'Serving HTTP on port 8000...'</span>)</span><br><span class=\"line\">httpd.serve_forever()</span><br></pre></td></tr></table></figure><p>当从HTTP客户端收到一个请求，服务器就调用simple_app去做逻辑处理并返回处理<br>的结果集。</p>\n<h4 id=\"中间件\">中间件<a href=\"#中间件\" title=\"中间件\"></a></h4><p>中间件有着如下功能</p>\n<ul><li>在重写environ之后，相应地根据目标URL把请求发到对应的应用对象。</li>\n<li>允许多个应用或者框架并行允许。</li>\n<li>通过网络来转发请求和相应，实现负载均衡和远程处理。</li>\n<li>对内容进行后续处理，比如应用XSL样式表</li>\n</ul><p>在web服务器和应用程序之间存在着中间件，在的django中存在的中间件去处理请求<br>视图，响应，模板，和异常，层层的包裹而形成了中间件栈(middleware stack)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self._request_middleware = []</span><br><span class=\"line\">self._view_middleware = []</span><br><span class=\"line\">self._template_response_middleware = []</span><br><span class=\"line\">self._response_middleware = []</span><br><span class=\"line\">self._exception_middleware = []</span><br></pre></td></tr></table></figure><p>那么这些中间件在出入栈的过程中，中间件的位置就成立相对位置，对服务器他是<br>应用，对于应用则他是服务.</p>\n<h3 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h3><ul><li><a href=\"https://www.python.org/dev/peps/pep-0333/\" target=\"_blank\">PEP 333 – Python Web Server Gateway Interface v1.0</a></li>\n<li><a href=\"http://www.hongweipeng.com/index.php/archives/1537/\" target=\"_blank\">hongweipeng</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760\" target=\"_blank\">liaoxuefeng</a></li>\n</ul>","prev":{"title":"再议三次握手","link":"2019/09/13/再议三次握手和四次挥手"},"next":{"title":"docker doc","link":"2019/09/01/docker doc"},"plink":"http://yoursite.com/2019/09/03/WSGI/","toc":[{"id":"web服务器和web框架","title":"web服务器和web框架","index":"1"},{"id":"wsgi","title":"WSGI","index":"2"},{"id":"django-中的wsgi","title":"django 中的WSGI","index":"3"},{"id":"参考","title":"参考","index":"4"}]}