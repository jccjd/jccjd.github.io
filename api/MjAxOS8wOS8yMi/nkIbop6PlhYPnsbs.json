{"title":"理解元类","date":"2019-09-21T16:00:00.000Z","link":"2019/09/22/理解元类","tags":["Python"],"categories":["Python"],"updated":"2019-10-25T08:13:57.896Z","content":"<h4 id=\"元类\">元类<a href=\"2019/09/22/理解元类#元类\"></a></h4><blockquote>\n<p>每个程序员都是一个魔法师，而元类做为<code>python</code>中最厉害的黑魔法，不经想让人<br>一探究竟。怎么学习呢当然是要用<code>魔法打败魔法</code></p>\n</blockquote>\n<p>Python中我们可以实现类的动态创建，可以在执行函数时去选择创建一个类</p>\n<pre><code>def choose(foo):\n    if foo == &apos;foo&apos;:\n        class foo(object):\n            pass\n        return foo\n    else:\n        class boo(object):\n            pass\n        return boo\nfoo = choose(&apos;foo&apos;)\nprint(type(foo)) #output: &lt;class &apos;type&apos;&gt;</code></pre><p>然后用type()去查看foo的类型时发现它居然是type类型，type类型是什么类型,type不是Python的自省函数，用来查询类型的吗，比如这样</p>\n<pre><code>def choose(foo):\n        pass\nlist = [1,2,3,4]\nprint(type(list)) #&lt;class &apos;list&apos;&gt;\nq = 10\nprint(type(q)) #&lt;class &apos;int&apos;&gt;\nprint(type(choose)) #&lt;class &apos;function&apos;&gt;</code></pre><p>像这样，可以知道list的类型是list 整数类型是int 函数的类型是function，日常使用中也并没有见到type这样的类型,那搜一下type是啥吧，然后发现type其实是有两种用法的，一种用来自省，还有一种居然可以构建类具体用法如下</p>\n<pre><code>#参数1：是要生成的类名，\n#参数2：是一个元组，用来继承父类\n#参数3： 是一个字典,用来填写函数内容\nfoo = type(&apos;foo&apos;,(),{&apos;bl&apos;:10})\n\nprint(foo) # &lt;class &apos;__main__.foo&apos;&gt;\nprint(type(foo)) # &lt;class &apos;type&apos;&gt;</code></pre><p>然后发现foo确实是被生成成一个类了，但他的类型也是type，一个类就是类嘛为什么是type呢，那我正常的去创建一个类去看看它到底是什么类型的</p>\n<pre><code>class demo():\n    pass\nprint(type(demo)) # &lt;class &apos;type&apos;&gt;</code></pre><p>我的天结果还是type类型，难道Python中的类都是由type创建的吗，这个type太NB了吧</p>\n<p>那接下来怎么办，这个元类到底是个啥呀，咱也不知道，咱也不敢说，咱也不敢问，那搜搜吧</p>\n<p>搜到非常NB的一句话：</p>\n<pre><code>在Python中的所有东西都是对象</code></pre><p>好像有道理啊，上面连类都可以像对象一样被创建，被操作，毫无作为类的威严啊，不是对象是啥，</p>\n<p>如果它长得像对象，叫声像对象，走路也像对象，那它就是个对象</p>\n<p>还有一句话：</p>\n<pre><code>type是一个元类</code></pre><p>那所有的类还真是被type，创建的。那么类相当于是type的实例对象，创建出来的类也可以实例化<br>也就是说type是类的类，</p>\n<p>好了咱明白，怪不得叫元类，元来是元始天尊的元啊，那咱就总结一下叫：</p>\n<pre><code>万类归元</code></pre><p>那它到底怎么用内，元类的主要用途就是在程序运行过程中去动态的对类进行修改，怎么去动态修改呢，<br>我们需要去定义一个元类A，然后去对<strong>new</strong>函数进行操作修改，那么当其他类去继承元类A的时候，那么其实就是执行了<br>元类A的<strong>new</strong>方法，然后这个元类A通过type函数去重新构建这个类，<br>比如要对一个类增加一个字段</p>\n<pre><code>#每个元类要继承type，type其实才是真 - 元类，或者type就叫元类，元类不是一类类，而是一个类,元类就是type（个人理解）\nclass MetaClassAdd(type):\n    def __new__(mcs, name, base, dict):\n        #这个dict包含了很多信息，要对其处理一下  \n        #像是含有这样的信息&lt;class &apos;dict&apos;&gt;: {&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;boo&apos;, &apos;id&apos;: &apos;jj&apos;}\n        #需要取boo类中的 id字段，将__开头的字段过滤掉                                \n        attrs = ((name,value) for name, value in dict.items() if not name.startswith(&apos;__&apos;)\n        mapping = dict((name, value) for name, value in attrs)\n        mapping[&apos;key&apos;] = &apos;value&apos;\n        return super(MetaClassAdd,mcs).__new__(mcs, name, base, dict)\nclass boo(metaclass=MetaClassAdd):\n    id = &apos;jj&apos;\nb = boo()\nprint(b.key) # 输出value</code></pre><p>像那么这样就可以做到了，其实这个很像是boo继承了MetaClassAdd，boo本身没有重写<strong>new</strong>,那么他去继承通过 metaclass关键字<br>去继承元类时，在创建完 id 字段后这个boo类只有id字段，而后在去找元类的<strong>new</strong>方法，添加了‘key’字段<br>更改完成后，再通过type去返回这个新构建的类</p>\n<p>在比如复杂一点的orm ，先定义一个MetaClassModel元类</p>\n<pre><code>class MetaClassModel(type):\n    def __new__(mcs, name, base, dct):\n        if name == &apos;Model&apos;:\n           return super(MetaClassModel, mcs).__new__(mcs, name, base, dct)\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith(&apos;__&apos;))\n        mapping = dict((name, value) for name, value in attrs)\n\n        for k in mapping:\n            dct.pop(k)\n        dct[&apos;__mapping__&apos;] = mapping\n        return super(MetaClassModel, mcs).__new__(mcs, name, base, dct)</code></pre><p>这个类的作用是根据不同的userModel生成不同 mapping,</p>\n<p>接着写 Model 类</p>\n<pre><code>#当然这是个假model\nclass Model(metaclass=MetaClassModel):\n    def save(self):\n        for k, v in self.__mapping__.items():\n            print(k, v)</code></pre><p>对数据增，删，改，查</p>\n<p>然后User类</p>\n<pre><code>class User(Model):\n    id = 1\n    name = &apos;ll&apos;\n    sex = &apos;ll&apos;\nclass good(Model):\n    id = 1\n    price = 100\n    count = 100\n\nusr = User()\ngood = good()\ngood.save()\nusr.save()</code></pre><p>这样用元类实现一个非常简单的orm</p>\n<p> 用元类实现 单例模式,为什么元类可以实现单例内，前面说过类也是对象，当在一堆实例面前，类是类<br>但在type面前就是个对象弟弟。</p>\n<pre><code>class Singleton(type):\n    def __init__(cls, name, base, dct):\n        super(Singleton, cls).__init__(name, base, dct)\n        cls._instance = None\n    def __call__(self, *args, **kwargs):\n        if self._instance == None:\n            self._instance = super(Singleton, self).__call__(*args, **kwargs)\n        return self._instance\n\nclass boo(metaclass=Singleton):\n    pass\nf = boo()\nb = boo()\nprint(f is b) #true</code></pre><p>Singleton去生成一个实例类boo，在其创建boo时加入一个标记，那么下面boo去生成实例对象的时候就要去Singleton中去找<strong>call</strong>函数<br>这样就控制了boo实例的创建，保证每次创建的对象只有一个</p>\n","prev":{"title":"nginx+uwsgi_django配置","link":"2019/09/25/nginx+uwsgi_django配置"},"next":{"title":"python特性","link":"2019/09/22/python特性"},"plink":"http://jccjd.top/2019/09/22/理解元类/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/09/22/理解元类/\" title=\"理解元类\">http://jccjd.top/2019/09/22/理解元类/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}