{"title":"理解元类","date":"2019-09-21T16:00:00.000Z","link":"2019/09/22/理解元类","tags":["Python"],"categories":["Python"],"updated":"2019-11-01T09:00:22.536Z","content":"<h4 id=\"元类\">元类<a href=\"2019/09/22/理解元类#元类\"></a></h4><blockquote>\n<p>每个程序员都是一个魔法师，而元类做为<code>python</code>中最厉害的黑魔法，不经想让人<br>一探究竟。怎么学习呢当然是要用<code>魔法打败魔法</code></p>\n</blockquote>\n<p>Python中我们可以实现类的动态创建，可以在执行函数时去选择创建一个类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose</span><span class=\"params\">(foo)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> foo == <span class=\"string\">'foo'</span>:</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> foo</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">boo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> boo</span><br><span class=\"line\">foo = choose(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">print(type(foo)) <span class=\"comment\">#output: &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>然后用type()去查看foo的类型时发现它居然是type类型，type类型是什么类型,type不是Python的自省函数，用来查询类型的吗，比如这样</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose</span><span class=\"params\">(foo)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">print(type(list)) <span class=\"comment\">#&lt;class 'list'&gt;</span></span><br><span class=\"line\">q = <span class=\"number\">10</span></span><br><span class=\"line\">print(type(q)) <span class=\"comment\">#&lt;class 'int'&gt;</span></span><br><span class=\"line\">print(type(choose)) <span class=\"comment\">#&lt;class 'function'&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>像这样，可以知道list的类型是list 整数类型是int 函数的类型是function，日常使用中也并没有见到type这样的类型,那搜一下type是啥吧，然后发现type其实是有两种用法的，一种用来自省，还有一种居然可以构建类具体用法如下</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#参数1：是要生成的类名，</span></span><br><span class=\"line\"><span class=\"comment\">#参数2：是一个元组，用来继承父类</span></span><br><span class=\"line\"><span class=\"comment\">#参数3： 是一个字典,用来填写函数内容</span></span><br><span class=\"line\">foo = type(<span class=\"string\">'foo'</span>,(),&#123;<span class=\"string\">'bl'</span>:<span class=\"number\">10</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">print(foo) <span class=\"comment\"># &lt;class '__main__.foo'&gt;</span></span><br><span class=\"line\">print(type(foo)) <span class=\"comment\"># &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>然后发现foo确实是被生成成一个类了，但他的类型也是type，一个类就是类嘛为什么是type呢，那我正常的去创建一个类去看看它到底是什么类型的</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">print(type(demo)) <span class=\"comment\"># &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n<p>我的天结果还是type类型，难道Python中的类都是由type创建的吗，这个type太NB了吧</p>\n<p>那接下来怎么办，这个元类到底是个啥呀，咱也不知道，咱也不敢说，咱也不敢问，那搜搜吧</p>\n<p>搜到非常NB的一句话：</p>\n<pre><code>在Python中的所有东西都是对象</code></pre><p>好像有道理啊，上面连类都可以像对象一样被创建，被操作，毫无作为类的威严啊，不是对象是啥，</p>\n<p>如果它长得像对象，叫声像对象，走路也像对象，那它就是个对象</p>\n<p>还有一句话：</p>\n<pre><code>type是一个元类</code></pre><p>那所有的类还真是被type，创建的。那么类相当于是type的实例对象，创建出来的类也可以实例化<br>也就是说type是类的类，</p>\n<p>好了咱明白，怪不得叫元类，元来是元始天尊的元啊，那咱就总结一下叫：</p>\n<pre><code>万类归元</code></pre><p>那它到底怎么用内，元类的主要用途就是在程序运行过程中去动态的对类进行修改，怎么去动态修改呢，<br>我们需要去定义一个元类A，然后去对<strong>new</strong>函数进行操作修改，那么当其他类去继承元类A的时候，那么其实就是执行了<br>元类A的<strong>new</strong>方法，然后这个元类A通过type函数去重新构建这个类，<br>比如要对一个类增加一个字段</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#每个元类要继承type，type其实才是真 - 元类，或者type就叫元类，元类不是一类类，而是一个类,元类就是type（个人理解）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetaClassAdd</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(mcs, name, base, dict)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#这个dict包含了很多信息，要对其处理一下  </span></span><br><span class=\"line\">        <span class=\"comment\">#像是含有这样的信息&lt;class 'dict'&gt;: &#123;'__module__': '__main__', '__qualname__': 'boo', 'id': 'jj'&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#需要取boo类中的 id字段，将__开头的字段过滤掉                                </span></span><br><span class=\"line\">        attrs = ((name,value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dict.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>)</span><br><span class=\"line\">        mapping = dict((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        mapping[<span class=\"string\">'key'</span>] = <span class=\"string\">'value'</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> super(MetaClassAdd,mcs).__new__(mcs, name, base, dict)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">boo</span><span class=\"params\">(metaclass=MetaClassAdd)</span>:</span></span><br><span class=\"line\">    id = <span class=\"string\">'jj'</span></span><br><span class=\"line\">b = boo()</span><br><span class=\"line\">print(b.key) <span class=\"comment\"># 输出value</span></span><br></pre></td></tr></table></div></figure>\n\n<p>像那么这样就可以做到了，其实这个很像是boo继承了MetaClassAdd，boo本身没有重写<strong>new</strong>,那么他去继承通过 metaclass关键字<br>去继承元类时，在创建完 id 字段后这个boo类只有id字段，而后在去找元类的<strong>new</strong>方法，添加了‘key’字段<br>更改完成后，再通过type去返回这个新构建的类</p>\n<p>在比如复杂一点的orm ，先定义一个MetaClassModel元类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetaClassModel</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(mcs, name, base, dct)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">'Model'</span>:</span><br><span class=\"line\">           <span class=\"keyword\">return</span> super(MetaClassModel, mcs).__new__(mcs, name, base, dct)</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dct.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>))</span><br><span class=\"line\">        mapping = dict((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> mapping:</span><br><span class=\"line\">            dct.pop(k)</span><br><span class=\"line\">        dct[<span class=\"string\">'__mapping__'</span>] = mapping</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super(MetaClassModel, mcs).__new__(mcs, name, base, dct)</span><br></pre></td></tr></table></div></figure>\n\n<p>这个类的作用是根据不同的userModel生成不同 mapping,</p>\n<p>接着写 Model 类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#当然这是个假model</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Model</span><span class=\"params\">(metaclass=MetaClassModel)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.__mapping__.items():</span><br><span class=\"line\">            print(k, v)</span><br></pre></td></tr></table></div></figure>\n\n<p>对数据增，删，改，查</p>\n<p>然后User类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(Model)</span>:</span></span><br><span class=\"line\">    id = <span class=\"number\">1</span></span><br><span class=\"line\">    name = <span class=\"string\">'ll'</span></span><br><span class=\"line\">    sex = <span class=\"string\">'ll'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">good</span><span class=\"params\">(Model)</span>:</span></span><br><span class=\"line\">    id = <span class=\"number\">1</span></span><br><span class=\"line\">    price = <span class=\"number\">100</span></span><br><span class=\"line\">    count = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">usr = User()</span><br><span class=\"line\">good = good()</span><br><span class=\"line\">good.save()</span><br><span class=\"line\">usr.save()</span><br></pre></td></tr></table></div></figure>\n<p>这样用元类实现一个非常简单的orm</p>\n<p> 用元类实现 单例模式,为什么元类可以实现单例内，前面说过类也是对象，当在一堆实例面前，类是类<br>但在type面前就是个对象弟弟。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(cls, name, base, dct)</span>:</span></span><br><span class=\"line\">        super(Singleton, cls).__init__(name, base, dct)</span><br><span class=\"line\">        cls._instance = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._instance == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self._instance = super(Singleton, self).__call__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">boo</span><span class=\"params\">(metaclass=Singleton)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">f = boo()</span><br><span class=\"line\">b = boo()</span><br><span class=\"line\">print(f <span class=\"keyword\">is</span> b) <span class=\"comment\">#true</span></span><br></pre></td></tr></table></div></figure>\n<p>Singleton去生成一个实例类boo，在其创建boo时加入一个标记，那么下面boo去生成实例对象的时候就要去Singleton中去找<strong>call</strong>函数<br>这样就控制了boo实例的创建，保证每次创建的对象只有一个</p>\n","prev":{"title":"python特性","link":"2019/09/22/python特性"},"next":{"title":"OSI","link":"2019/09/22/OSI"},"plink":"http://jccjd.top/2019/09/22/理解元类/","copyright":{"link":"<a href=\"http://jccjd.top/2019/09/22/理解元类/\" title=\"理解元类\">http://jccjd.top/2019/09/22/理解元类/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}