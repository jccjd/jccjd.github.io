{"title":"OSI","date":"2019-09-21T16:00:00.000Z","link":"2019/09/22/OSI","tags":["计算机网络"],"categories":["计算机网络"],"updated":"2019-10-25T08:16:39.365Z","content":"<h3 id=\"OSI七层参考模型\">OSI七层参考模型<a href=\"2019/09/22/OSI#OSI七层参考模型\"></a></h3><p>OSI 开放式的系统互联，学术上是分为7层，但在实际的应用中只有五层的结构</p>\n<p>最顶层的<code>应用层(application layer)</code> 就是平时我们能够接触到的http https ftp dns snmp 等协议我们能</p>\n<p>用来上网，发邮件，下载电影等等，在信息发送的过程中，需要<code>表示层(persentation layer)</code>对数据进行加密，或者数据压缩,以保证两个系统间的消息发送</p>\n<p>能相互被识别，通过加密而确保安全。<code>会话层(session layer)</code>就是负责建立，管理中断，表示层实体之间的通信会话。该层的通信由设备中的应用程序之间的服务请求和相应组成</p>\n<p><code>传输层(transport layer)</code>建立了主机端到端的链接，把传输表头加至数据以形成数据包。传输表头包含了所有使用的<br>协议等发送信息。列如：传输控制协议TCP<br><code>网络层(Network layer)</code>决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。<br>网络表头包含了网络数据.如ip<br><code>数据链路层（data Link Layer）</code> 负责网路寻址，错误侦测和改错。当表头和表尾被加至数据包<br>时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾是一串指示数据<br>包末端的字符串。如以太网，无线局域网</p>\n<p>分为两个子层：逻辑链路(<code>llc</code>logical link control)控制子层和介质访问控制（<code>Mac</code> medium access control）子层</p>\n<p><code>物理层</code>在局部局域网上传输数据帧，负责计算机通讯设备和网络媒体之间的互通-网线,网卡等</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>layer</th>\n<th>work</th>\n<th>protocol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>文件传输，电子邮件，文件服务，虚拟终端</td>\n<td>TFTP HTTP SNMP FTP DNS</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>数据格式化，代码转化，数据加密</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>解除或建立与别的节点的联系</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>提供端对端的接口</td>\n<td>TCP UDP</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>为数据包选择路由</td>\n<td>IP ICMP RIP OSPF BGP IGMP</td>\n</tr>\n<tr>\n<td>链路层</td>\n<td>传输有效地址的祯以及错误检测</td>\n<td>SLIP CSLIP PPP ARP RARP MTU</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>以二进制数据形式在物理媒体上传输数据</td>\n<td>ISO2110 IEEE802 IEEE802.2</td>\n</tr>\n</tbody></table></div></div>\n<p>这些模型规定了这么多的协议，层级，目的当然是为了让网络通信能够安全愉快的进行下去了<br>要与外界通信，首先要先确定我们能和其他终端互联，在一个局域网也好，在以太网也好，那么需要测试一下<br>可以通过<code>ping</code>来对其他终端发送数据报，然后通过反馈来确定是否联通了</p>\n<p><code>ping</code>命令是在网络层的，它是依据icmp协议的，那么在它发送数据的过程中发生了如下的几个过程</p>\n<p>生成一个数据包，包含有date 和 type type就是他的协议类型，也就是ICMP<br>然后经过经过本层的ip协议，增一个ip首部，有源地址，和目标地址，就成了ip报文段， 一般会根据子网掩码（位运算）来判断是否在同一局域网<br>（&gt; 这一步好像是没啥卵用啊，不管网络层知不知道这个ip是否在同一网段，都要在数据链路层去ARP查找目标ip对应的MAC）<br>（&gt; 在网络层会根据源ip和目标ip 进行运算判断是否在同一局域网，来决定发给交换机还是路由器！）<br>（&gt; 存疑，感觉不太对，但继续往下走吧）</p>\n<p>经网络层封装后成为IP数据报，到了数据链路层，这一层会根据ARP 查询目标IP是否在ARP cache中，有的话将加上目标IP,和目标MAC，再次装帧<br>发给交换机，交换机会将源MAC地址和端口记录到MAC地址和端口对应表中，然后交换机检查自己的mac地址表中是否有对应的端口号，如果没有<br>那么交换机，将此数据帧，发给所有端口的机器，然后每台机器自查，如果不是自己的ＩＰ那么就丢弃数据帧，如果目标地址检查到是发给自己的</p>\n<p>（&gt; 在交换机 不知道目标地址的ＭＡＣ-端口映射表时，而将源帧无目的群发的行为叫做flooding）</p>\n<p>那么就回应,将自己的ＩＰ端口号，ＭＡＣ地址，和源ＩＰ，ＭＡＣ地址，端口号封装成帧，发给源ＩＰ<br>那么在回复目标ＩＰ的时候，经过交换机，那么交换机记录目标地址的ＭＡＣ地址和端口更新交换机的ＭＡＣ-端口映射表，那么下一次该源地址和目标地址<br>就能实现单播，</p>\n<p>（&gt; 至少是短时间内，源ＩＰ的ＡＲＰ表，可能会被更新，而之前的记录能被覆盖）</p>\n<p>（&gt; 交换机没有ＡＲＰ协议，有一个ＭＡＣ地址和端口的对应表，这只是针对二层交换机）<br>这是在局域网中的活动，</p>\n<p>(&gt; 由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，<br>因此通常指的网关就是路由器的IP)</p>\n<p>(&gt;这是一个路由器，必须要对广播进行回应，要不然就没法提供DHCP服务了)</p>\n<p>如果源ip和目标ip在不同网段，那么这个广播在局域网内得不到回应，ARP到了路由器，路由器将源ip，和源MAC，端口号记录，<br>并回复源ＩＰ，源IP和ＭＡＣ都为路由器的地址和ip，ＭＡＣ,经过交换机时，交换机学习一下，然后单播给目标ip，<br>目标ＩＰ得到了网关的ＭＡＣ，将包ping到网关，然后网关发现目标ＩＰ不再同一网段，然后将目标的ＭＡＣ地址替换成下一路由的ＭＡＣ,<br>继续转发，直到找到目标ＩＰ的网段，然后查找自己ＡＲＰ cache 找到目标ＭＡＣ,再将目标ＭＡＣ地址换成真正的目标MAC地址<br>然后路由器更新ARP cache,目标机器也更新ARP cache, 目标机器开始，对数据包开始拆包，得到ＩＣＭＰ协议，然后将回回复源ip<br>由于源ip和目标ip不再同一网段，在回复的过程中，目标ip将源ip和源mac装帧，加上自己的ip mac，在局域网中依然是找不到源ip的<br>所以在通过路由时会将源mac换成路由的mac，去路由中对应的网段，找不到就跳到下一路由，将源mac换成下一路由的mac，在下一路由的网段中<br>找到相同网段，读取，ＡＲＰ cache 的得到交换机的端口，将包发到交换机，在又交换机，端口-ＭＡＣ,找到对应的源mac，完成一次ping<br>过程</p>\n<p>当然日常的上网肯定不是使用ICMP的协议，而是使用应用层的协议，比如HTTP，FTP，NFS，DNS等</p>\n<p>那么一次网页请求的过程就更加的复杂了，首先我理解的过程，对与一个网址，要访问一个网站的过程<br>对于网址，一般的网站都被<code>DNS</code>映射成了字符的形式，那么首先应该是DNS将网址解析成对应的ip地址，然后对这个ip进行访问<br>解析完成后就要发送http请求，那么对于应用层的http肯定要结果下面几层的层层包装，首先是表示层对数据进行加密，对数据的一些<br>处理然后Session layer 这个层是建立连接管理中断，那不是和tcp冲突了，实际中上三层被归化成一起了，这个有问题先搁置<br>然后走到TCP/UDP层，也即使transport layer这一层开始有协议了，tcp，是稳定连续的连接，udp包发完就不管了，要看一个网站<br>当然是要一个稳定连续可交互的协议，当然是选择TCP协议了，那么要建立一次tcp的稳定连接，当然要用TCP的三次握手协议，<br>那么此时的http请求的用户数据暂时搁置在这里，要进行tcp连接通道的建立，tcp<br>给目标地址的端口，对了这时候是需要端口的，http在请求时<br>就包含了目标地址的端口,一般是隐式的，但（这个端口好像没有啊存疑）tcp开始给目标机器发送一个同步请求SYN=1和一个生成的数字num=x，<br>源地址ip加上目标地址ip，和type协议类型，在经过数据链路层加上一个MAC地址头部和CRC包损坏标识，封装成数据帧，转换成高低电压<br>经过光纤双绞线等物理介质也就是物理层。目标机器得到这么些的电信号,从物理层电信号开始<br>转换成数据帧，数据链路层去校验CRC是否完整，如果不完整就将其丢弃，（丢去之后呢，怎么要求重发啊）检验完整，<br>开始继续拆包，得到得到源ip的MAC地址，再拆得到目标ip，此时还在数据链路层，这时候<br>应该在路由器中，ARP<br>检索，或者广播得到ip对应的MAC地址，将其发送过去（等等，这个<br>目标地址的MAC<br>是在路由中解析的也就是，路由已经将原始数据包拆了一次，拆到了源ip，源mAC，和目标IP<br>得到目标ip后，再ARP在路由表中通过目标ip找到对应的机器MAC，然后在将数据装好，发给目标IP的MAC<br>目标机器得到数据帧后在进行拆分，校验CRC，得到源机器的MAC地址，和对应的ip地址，<br>此时在APR缓存中写入这一次请求，然后到网络层，拆开得到ip了，（这里有一个问题）<br>就是ARP缓存是什么时候写入的，在数据链路层的时候只得到了 mAC 在<br>网络层才得到ip 是神马时候写入的呢，<code>？</code> 然后到了<code>transport layer</code><br>拆封发现是使用的TCP 的type，得到了另一台机器的同步申请<br>和随机产生的数字。目标机器的TCP<br>此时回复的信息就是确认收到ACK=1，然后将源地址的随机数字<br>+1,在产生一个随机数字，经过层层的打包，发送回源地址，还是经过传输层，网络层，数据链路层<br>物理层发送回去，源地址得到回应，并确定了服务器回复的数字是一开始生成的数字加一，<br>然后在回复ACK=1确认受到，和目标机器产生的随机数+1并发送http的date,打包发给<br>目标机器，目标机器受到确认，然后tcp连接建立，目标机器发送给请求地址传输数据tcp建立连接</p>\n<p>数据传输完成后，开始关闭tcp连接，因为tcp连接是占据资源的<br>数据传输完成后如果客户端在一个时间段没有动作，那么就会关闭tcp连接，服务端完成<br>服务端，发个FIN=1 随机数m 表示完成了，客户端收到，回个ACK=1 m+1 表示知道了<br>如果客户端想关闭这次tcp服务，那么就会给客户端发送FIN=1 随机数k, 服务端收到<br>在回个ACK=1 k+1 就会关闭这次连接，</p>\n<p>这些五层或者是七层的模型就是为了，保证通信过程能够顺利安全的进行<br>要进行一次完整的通信过程，<br>首先在应用层，发送要发送的报文一般指的是完整的信息，传输层实现报文交付<br>传输层：报文段<br>网络层：分组</p>\n<p>路由器与交换机的差别，路由器是属于OSI第三层的产品，交換机是OSI第二层的产品。第二层的产品功能在于，<br>将网络上各个计算机的MAC地址记在MAC地址表中，当局域网中的计算机要经过交換机去交换传递数据时，<br>就查询交換机上的MAC地址表中的信息，将数据包发送给指定的计算机，而不会像第一层的产品（如集线器）每台在网络中的计算机都发送。<br>而路由器除了有交換机的功能外，更拥有路由表作为发送数据包时的依据，在有多种选择的路径中选择最佳的路径。<br>此外，并可以连接两个以上不同网段的网络，而交換机只能连接两个。<br>并具有IP分享的功能，如：区分哪些数据包是要发送至WAN。路由表存储了（向前往）某一网络的最佳路径，该路径的“路由度量值”以及下一个（跳路由器）。<br>参考条目路由获得这个过程的详细描述。</p>\n<p>尽管也有其它一些很少用到的被路由协议，但路由通常指的就是IP路由。</p>\n","prev":{"title":"nginx+uwsgi_django配置","link":"2019/09/25/nginx+uwsgi_django配置"},"next":{"title":"理解元类","link":"2019/09/22/理解元类"},"plink":"http://jccjd.top/2019/09/22/OSI/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/09/22/OSI/\" title=\"OSI\">http://jccjd.top/2019/09/22/OSI/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}