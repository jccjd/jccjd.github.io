{"title":"python特性","date":"2019-09-21T16:00:00.000Z","link":"2019/09/22/python特性","tags":["Python"],"categories":["Python"],"updated":"2019-11-01T09:05:29.061Z","content":"<h4 id=\"python的函数参数传递\">python的函数参数传递<a href=\"2019/09/22/python特性#python的函数参数传递\"></a></h4><p>python的所有变量都可以理解是内存中一个对象的“引用”,类型是属于对象的，而不是变量。对象有两种，“可更改与不可更改。在python中，string,tuples,和numbers是不可更改的对象，而list，dict，set等则是可以修改的对象。</p>\n<h4 id=\"python的标准数据类型\">python的标准数据类型<a href=\"2019/09/22/python特性#python的标准数据类型\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers(int long float complex)</span><br><span class=\"line\">string</span><br><span class=\"line\">List</span><br><span class=\"line\">Tuple</span><br><span class=\"line\">Dictionary</span><br></pre></td></tr></table></div></figure>\n<h5 id=\"string\">string<a href=\"2019/09/22/python特性#string\"></a></h5><p>   重点是对string的切片</p>\n<pre><code>从左到右0 - n：0,1,2,3....\n从右到左-n - -1:-n,...-3,-2, -1\n切片时要头下标和尾下标和步长</code></pre><h5 id=\"list\">list<a href=\"2019/09/22/python特性#list\"></a></h5><p>可以存放更多的数据类型，切片方式和string类似</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [ <span class=\"string\">'runoob'</span>, <span class=\"number\">786</span> , <span class=\"number\">2.23</span>, <span class=\"string\">'john'</span>, <span class=\"number\">70.2</span> ]</span><br><span class=\"line\">tinylist = [<span class=\"number\">123</span>, <span class=\"string\">'john'</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> list               <span class=\"comment\"># 输出完整列表</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> list[<span class=\"number\">0</span>]            <span class=\"comment\"># 输出列表的第一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> list[<span class=\"number\">1</span>:<span class=\"number\">3</span>]          <span class=\"comment\"># 输出第二个至第三个元素</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> list[<span class=\"number\">2</span>:]           <span class=\"comment\"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> tinylist * <span class=\"number\">2</span>       <span class=\"comment\"># 输出列表两次</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> list + tinylist    <span class=\"comment\"># 打印组合的列表</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"python元类（metaclass\">python元类（metaclass)<a href=\"2019/09/22/python特性#python元类（metaclass\"></a></h4><p>用于orm的单例模式，对数据库对象实现保护，确保全局只有一个数据库对象<br>metaclass，直译为元类，简单的解释就是：</p>\n<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p>\n<p>连接起来就是：先定义metaclass，就可以创建6类，最后创建实例。<br>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>\n<h4 id=\"staticmethod，和-classmethod\">@staticmethod，和@classmethod<a href=\"2019/09/22/python特性#staticmethod，和-classmethod\"></a></h4><p>python有三种方法即静态方法(staticmethod)，类方法(classmethod)和实例方法</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">print(<span class=\"string\">\"executing foo(%s)\"</span>%(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self,x)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"executing foo(%s,%s)\"</span>%(self,x))</span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">class_foo</span><span class=\"params\">(cls,x)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"executing class_foo(%s,%s)\"</span>%(cls,x))</span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">static_foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"executing static_foo(%s)\"</span>%x)</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"类变量和实例变量\">类变量和实例变量<a href=\"2019/09/22/python特性#类变量和实例变量\"></a></h4><h5 id=\"类变量：\">类变量：<a href=\"2019/09/22/python特性#类变量：\"></a></h5><pre><code>是可以在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）</code></pre><h5 id=\"实例变量：\">实例变量：<a href=\"2019/09/22/python特性#实例变量：\"></a></h5><pre><code>实例化之后，每个实例单独拥有的变量。</code></pre><h5 id=\"python自省\">python自省<a href=\"2019/09/22/python特性#python自省\"></a></h5><p>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型，简单一句就是运行时能够获得对象的类型，比如type(),dir(),getattr(),hasattr(),isinstance()</p>\n<h4 id=\"python中的单下划线和双下划线\">python中的单下划线和双下划线<a href=\"2019/09/22/python特性#python中的单下划线和双下划线\"></a></h4><p><strong>function</strong>:一种约定，python内部的名字，用来区别其他用户自定义的命名，以防止冲突，如<strong>init</strong>,<strong>del</strong>,等python内置函数</p>\n<p>_foo:一种约定用来指定变量私有，程序员用来指定私有变量的一种方式，不能用from module import * 导入</p>\n<p><strong>foo:解释器用_classname</strong>foo来代替这个名字，以区别和其他类相同的命名，它无法直接像公有成员一样随便访问，通过对象名，类名__xx来访问</p>\n<h4 id=\"迭代器和生成器\">迭代器和生成器<a href=\"2019/09/22/python特性#迭代器和生成器\"></a></h4><p>将列表生成式中[]改成()之后数据结构将改变，从列表变为生成器</p>\n<p>列表的容量是有限的，而且，创建一个包含百万元素的列表，不仅是占用很大内存空间的，</p>\n<p>在python中我们可以采用生成器：边循环，边计算的机制</p>\n<h4 id=\"args-and-kwargs\"><em>args and *</em>kwargs<a href=\"2019/09/22/python特性#args-and-kwargs\"></a></h4><p>当你不确定你的函数里将要传递多少参数时你可以用*args，它可以传递任意数量的参数</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_everything</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> count, thing <span class=\"keyword\">in</span> enumerate(args):</span><br><span class=\"line\">             <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class=\"line\">print_everything(<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'cabbage'</span>)</span><br><span class=\"line\"><span class=\"number\">0.</span> apple</span><br><span class=\"line\"><span class=\"number\">1.</span> banana</span><br><span class=\"line\"><span class=\"number\">2.</span> cabbage</span><br></pre></td></tr></table></div></figure>\n<p>**kwargs允许你使用没有事先定义的参数名：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_everything</span><span class=\"params\">(**kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> count, thing <span class=\"keyword\">in</span> kwargs(args):</span><br><span class=\"line\">             <span class=\"keyword\">print</span> <span class=\"string\">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class=\"line\">print_everything(apple = <span class=\"string\">'fruit'</span>, cabbage = <span class=\"string\">'vegetable'</span>)</span><br><span class=\"line\">cabbage = vegetable</span><br><span class=\"line\">apple = fruit</span><br></pre></td></tr></table></div></figure>\n<p>也可以混合使用，在使用时<em>args 和*</em>kwargs必须是有顺序的</p>\n<h4 id=\"鸭子类型\">鸭子类型<a href=\"2019/09/22/python特性#鸭子类型\"></a></h4><h4 id=\"python中的重载\">python中的重载<a href=\"2019/09/22/python特性#python中的重载\"></a></h4><p>函数重载主要是为了解决两个问题</p>\n<ul>\n<li>1.可变参数类型</li>\n<li>2.可变参数个数</li>\n</ul>\n<p>一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载<br>，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数</p>\n<p>python可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在python中很可能是相同的代码，没有必要做成两个函数</p>\n<p>如果参数个数不同，python中的缺省参数，对于那些缺少的参数设定为缺省参数，</p>\n<p>所以python是不需要重载的</p>\n<h4 id=\"python中的作用域\">python中的作用域<a href=\"2019/09/22/python特性#python中的作用域\"></a></h4><p>python中，一个变量的作用域总是由在代码中被赋值的地方所决定的</p>\n<p>当python遇到一个变量的话他会按照这样的顺序进行搜索</p>\n<p>本地作用域（local）- 当前作用域被嵌入的本地作用域（Enlosing)-全模块/全局作用域-内置作用域（built-in)</p>\n<h4 id=\"GIL线程全局锁\">GIL线程全局锁<a href=\"2019/09/22/python特性#GIL线程全局锁\"></a></h4><p>线程全局锁（Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制，就是一个核只能在同一时间运行一个线程，</p>\n<p>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，Python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢</p>\n<h4 id=\"协程\">协程<a href=\"2019/09/22/python特性#协程\"></a></h4><p>简单点说协程是线程和进程的升级版吗，进程和线程都面临着内核态和用户态的切换问题而耗费许多时间，而协程就是用户自己控制切换的时机</p>\n<h4 id=\"闭包\">闭包<a href=\"2019/09/22/python特性#闭包\"></a></h4><p>闭包（closeure）是函数式编程的重要语法结构，闭包也是一种组织代码的结构，它同样提高了代码的可重复实用性。<br>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包，闭包必须满足一下几点：</p>\n<pre><code>1，必须有一个内嵌函数\n2，内嵌函数必须引用外部函数中的变量\n3，外部函数的返回值必须是内嵌函</code></pre><h4 id=\"lambda函数\">lambda函数<a href=\"2019/09/22/python特性#lambda函数\"></a></h4><p>匿名函数，通常用在函数式编程中</p>\n<h4 id=\"Python函数式编程\">Python函数式编程<a href=\"2019/09/22/python特性#Python函数式编程\"></a></h4><p>Python函数式编程支持<br>filter函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素，返回一个使bool——seq返回值为true的元素的序列</p>\n<p>map函数是对一个序列的每个项依次执行函数</p>\n<p>reduce函数是对一个序列的每个项迭代调用函数</p>\n<h4 id=\"Python中的拷贝\">Python中的拷贝<a href=\"2019/09/22/python特性#Python中的拷贝\"></a></h4><p>引用和copy(),deepcopy()的区别</p>\n<h4 id=\"python垃圾回收机制\">python垃圾回收机制<a href=\"2019/09/22/python特性#python垃圾回收机制\"></a></h4><p>python GC 主要使用引用计数（reference counting) 来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep) 解决容器对象可能产生的循环引用问题，通过“分带回收（generation collection)以空间换时间提高垃圾回收效率</p>\n<h5 id=\"引用计数\">引用计数<a href=\"2019/09/22/python特性#引用计数\"></a></h5><p>pyObject是每个对象必有的内容，其中ob_refcnt就是作为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，<br>它的ob_refcnt就会减少，引用计数为0时，该对象生命就结束了</p>\n<h5 id=\"标记清除机制\">标记清除机制<a href=\"2019/09/22/python特性#标记清除机制\"></a></h5><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点，以引用为边构成图，把所有可以访问到的对象打上标记，然后清理一遍内存空间，把所有没标记的对象释放</p>\n<h5 id=\"分代技术\">分代技术<a href=\"2019/09/22/python特性#分代技术\"></a></h5><p>分代回收的整体思想是：将系统中所有内存块根据其存活时间划分不同的集合，每个集合就成为一个代，垃圾回收频率随着代的存活时间的增加而减小，存活时间通常利用经过几次垃圾回收来度量</p>\n<p>Pytho默认定义了三代对象集合，索引数越大，对象存活时间越长</p>\n<p>当某些内存块m经过了3次垃圾收集的清洗之后还存活时，我们将内存块M划分到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔很长时间，就使得垃圾回收机制需要处理的内存少了，效率自然提高，<br>在这个过程中，集合B中的某些内存由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>\n<h4 id=\"Python的list\">Python的list<a href=\"2019/09/22/python特性#Python的list\"></a></h4><h4 id=\"Python的is\">Python的is<a href=\"2019/09/22/python特性#Python的is\"></a></h4><p>is是对比地址 ==是对比值</p>\n<h4 id=\"read，readline-和readlines\">read，readline 和readlines<a href=\"2019/09/22/python特性#read，readline-和readlines\"></a></h4><ul>\n<li>read读取整个文件</li>\n<li>readline读取下一行,使用生成器方法</li>\n<li>readlines读取整个文件到一个迭代器以供我们遍历<h4 id=\"Python2和Python3的区别\"><a href=\"2019/09/22/python特性#Python2和Python3的区别\" class=\"headerlink\" title=\"Python2和Python3的区别\"></a>Python2和Python3的区别</h4><h2 id=\"range-and-xrange\"><a href=\"2019/09/22/python特性#range-and-xrange\" class=\"headerlink\" title=\"range and xrange\"></a>range and xrange</h2></li>\n<li>xrange的内存性能更好</li>\n<li>都在循环中使用</li>\n</ul>\n<p>当使用range时会生成一个list开辟一大块空间，而xrange则会生成一个可迭代的对象</p>\n<p>Python3中没有xrange，range和Python2中的xrange相同</p>\n<h4 id=\"cls-和self\">cls 和self<a href=\"2019/09/22/python特性#cls-和self\"></a></h4><p>(在p2中)self 表示一个具体的实例本身.</p>\n<p>cls表示这个类本身<br>類先調用<strong>new</strong>方法返回該類的實例對象這個實例對象就是<strong>init</strong>方法的第一個參數self</p>\n<p>即self是<strong>new</strong>的返回值</p>\n<p>py3中沒有區別</p>\n","prev":{"title":"nginx+uwsgi_django配置","link":"2019/09/25/nginx+uwsgi_django配置"},"next":{"title":"理解元类","link":"2019/09/22/理解元类"},"plink":"http://jccjd.top/2019/09/22/python特性/","toc":[{"title":"","id":"range-and-xrange","index":"1"}],"copyright":{"link":"<a href=\"http://jccjd.top/2019/09/22/python特性/\" title=\"python特性\">http://jccjd.top/2019/09/22/python特性/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}