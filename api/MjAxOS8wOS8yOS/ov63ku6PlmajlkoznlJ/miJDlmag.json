{"title":"迭代器和生成器","date":"2019-09-28T16:00:00.000Z","link":"2019/09/29/迭代器和生成器","tags":["Python"],"categories":["Python"],"updated":"2019-10-25T08:20:43.396Z","content":"<h4 id=\"迭代器-iterator\">迭代器(iterator)<a href=\"2019/09/29/迭代器和生成器#迭代器-iterator\"></a></h4><p>迭代器是一个可以记住遍历位置的对象<br>迭代器对象从集合的第一个位置访问，直到所有元素被访问完，切只能前进不能后退</p>\n<p>有两个基本的方法：iter()创建迭代器，next()访问迭代器一次只能取一个</p>\n<pre><code>list = [1,2,3,4]\niterw = iter(list)\nprint(next(iterw))</code></pre><p>常用的 字符串，列表 元组，字典都可用来创建迭代器</p>\n<p>可以被常规for语句访问，用while语句时要用next() 函数，但注意当迭代器遍历结束时next()函数会抛出停止迭代的异常，即可结束迭代</p>\n<pre><code>list = [1,2,3,4]\niters = iter(list)\nwhile True:\n    try:\n         print(next(iters))\n    except StopIteration:\n        break</code></pre><h4 id=\"创建一个迭代器\">创建一个迭代器<a href=\"2019/09/29/迭代器和生成器#创建一个迭代器\"></a></h4><p>除了传统的，用字符串，列表，元组，字典外，还可以自己实现一个迭代器<br>在上面的字典，列表元组中，他们有一个共同的特点，都实现了<strong>iter</strong>,<strong>next</strong>这两个内置函数<br>只要实现这两个协议那么我们就可以创建一个自己的迭代对象,我们可以实现一个简单的range()函数，返回指定长度的数列，通过start，end,返回一个定长数列</p>\n<pre><code>class myrange:\n  def __init__(mcs,start,end):\n      mcs.start = start\n      mcs.end = end\n\n  def __iter__(mcs):\n      return mcs\n\n  def __next__(mcs):\n      if mcs.start &lt;= mcs.end:\n          number = mcs.start\n          mcs.start += 1\n          return number\n      else:\n          raise StopIteration</code></pre><p>在py3中range()就是用迭代器来实现的，当我们要生成数列的时候，不必要一次性生成全部的数列可以减少空间开销</p>\n<h4 id=\"生成器\">生成器<a href=\"2019/09/29/迭代器和生成器#生成器\"></a></h4><p>一个包含yield 关键字的函数就是一个生成器函数。<br>生成器的本质就是迭代器<br>当用了这个关键字时，可以返回值，不同于return ,yield返回值后，该函数会在返回结果后挂起，下次调用时继续执行，<br>调用生成器函数不会得到返回的具体值，而是得到一个可迭代对象。不会一次性在内存中生成太多数据</p>\n<pre><code>def product():\n    for i in range(100):\n        yield i\n\nproduce = product()\nprint(produce.__next__())\n\nprint(produce.__next__())\nprint(next(produce))\n\n# number = 0\n# for i in produce:\n#     print(i)\n#     number += 1\n#     if number == 5:\n#\n#         break</code></pre><h4 id=\"生成器表达式\">生成器表达式<a href=\"2019/09/29/迭代器和生成器#生成器表达式\"></a></h4><pre><code>#列表推导式\nlist = [i for i in range(10)]\n# 生成器表达式\nlist1 = (i for i in range(10))\nprint(list)\n# 返回一个数列[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(list1)\nprint(next(list1))#next本质就是调用__next__\n# 返回以个生成器对象&lt;generator object &lt;genexpr&gt; at 0x000001DDB26C5F48&gt;</code></pre><ol>\n<li>把列表解析式的[]换成()得到的就是生成器表达式</li>\n<li>python不但使用迭代器协议，让for循环变得更加通用，大部分内置函数，也是使用迭代协议访问对象。例如sum函数是Python的内置函数，该函数使用迭代器协议访问对象，而生成器实现迭代器协议。</li>\n</ol>\n","prev":{"title":"贝叶斯分类器","link":"2019/10/03/贝叶斯分类器"},"next":{"title":"闭包","link":"2019/09/27/闭包"},"plink":"http://jccjd.top/2019/09/29/迭代器和生成器/","reward":true,"copyright":{"link":"<a href=\"http://jccjd.top/2019/09/29/迭代器和生成器/\" title=\"迭代器和生成器\">http://jccjd.top/2019/09/29/迭代器和生成器/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}