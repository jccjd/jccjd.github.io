{"title":"项目重点","date":"2019-10-26T16:00:00.000Z","link":"2019/10/27/项目重点","tags":["project"],"updated":"2019-10-29T08:57:22.656Z","content":"<hr>\n<h3 id=\"状态保持\">状态保持<a href=\"2019/10/27/项目重点#状态保持\"></a></h3><p>当用户注册登录成功之后，那么下次用户在登录网站时不用在输入密码，至少在短期内不用重复的输入密码，</p>\n<p>如何实现呢，这就需要保持用户的登录状态：将通过认证的用户的唯一标示信息写入到当前浏览器的cookie和session中</p>\n<p><strong>使用django</strong></p>\n<ul>\n<li>django用户认证系统提供了<code>login</code>方法，</li>\n<li>login()位置： <code>django.contrib.auth.__init__.py</code></li>\n<li>保持状态<code>session</code>数据存储的位置<ul>\n<li>SESSION_ENGINE = ‘django.contrib.sessions.backends.cache’</li>\n<li>SESSION_CASHE_ALIAS = ‘session’     # redis数据库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pipeline操作Redis\">pipeline操作Redis<a href=\"2019/10/27/项目重点#pipeline操作Redis\"></a></h3><p>redis 的c-s架构</p>\n<ul>\n<li>基于客户端-服务模型以及请求响应的TCP服务</li>\n<li>客户端向服务端发送一个查询请求，并监听Socket返回</li>\n<li>通常是以阻塞模式，等待服务器响应</li>\n<li>服务端处理命令，并将结果返回给客户端</li>\n</ul>\n<p>如果<code>Redis</code>服务端要同时处理多个请求，加上网络延迟，那么服务端利用率不高，效率低，解决方法就是队列，将多条命令执行完后在一次性返回</p>\n<p><strong>pipeline</strong></p>\n<blockquote>\n<p>管道pipeline</p>\n<ul>\n<li>可以一次性发送多条命令并在执行完成后一次性将结果返回</li>\n<li>pipeline通过减少客户端与Redis的通信次数来实现降低往返延时</li>\n</ul>\n</blockquote>\n<h3 id=\"RabbitMQ-和-Celery\">RabbitMQ 和 Celery<a href=\"2019/10/27/项目重点#RabbitMQ-和-Celery\"></a></h3><p>在用户注册过程中，需要发送短信验证码，发送短信的过程是耗时的操作，如果这事短信被阻塞，用户响应将会延迟，所以发送短信的过程是需要异步的，发送短信和响应 应该分开执行，发送短信从主业务中解耦出来。</p>\n<p><strong>生产者和消费者模式</strong></p>\n<p>生产者和消费者是最常用的解耦方式之一，寻找一个中间人，保证两个业务之间没有直接关联</p>\n<ul>\n<li>生产者生成消息，缓存到消息队列中，消费者读取消息队列中的消息并执行</li>\n<li>消息队列是消息在传输过程中保存消息的容器</li>\n</ul>\n<p>RabbitMQ 具有很高的系统吞吐量，持久化消息，和高并发等特性</p>\n<p>在处理消息队列中的消息的时候会有如下问题：</p>\n<ul>\n<li>任务可能出现高并发的情况，需要补充多任务的方式执行</li>\n<li>耗时任务很多种，每种耗时任务编写的生产者和消费者代码重复</li>\n<li>取到的消息执行方式，不能确定</li>\n</ul>\n<p>这些消息的处理可以通过Celery来执行</p>\n<p><strong>Celery</strong></p>\n<ul>\n<li>一个简单，灵活可靠，能处理大量消息的分布式的系统，可以在一台或者多台机器上运行</li>\n<li>单个Celery进程每分钟可以处理百万计的任务</li>\n<li>通过消息进行通信，使用消息队列在客户端和消费者之间进行协调</li>\n</ul>\n<h3 id=\"FastDFS\">FastDFS<a href=\"2019/10/27/项目重点#FastDFS\"></a></h3><p>文件存储时，使用FastDFS来做图片的存储</p>\n<ul>\n<li>FastDFS是用c语言编写的一款开源的轻量级分布式文件系统</li>\n<li>功能包括: 文件存储，文件访问，文件同步，解决了大容量存储和负载均衡的问题，特别适合以文件为载体的在线服务，如相册网站，视频网站</li>\n<li>为互联网定制，充分考虑了冗余备份，负载均衡，线性扩容等机制，并注重高可用，高性能</li>\n<li>可以帮助我们搭建一套高性能的文件服务器集群，并提供文件上传下载等服务</li>\n</ul>\n<p><strong>FastDFS架构</strong></p>\n<ul>\n<li>包括<code>client</code>， <code>Tracker server</code>， <code>storage server</code>，client请求tracker进行文件上传，下载，tracker再调度storage完成上传和下载</li>\n<li>Client: 客户端，业务请求的发起方，通过专有接口，使用TCP/IP协议与Tracker或storage进行数据交互，</li>\n<li>Tracker server：跟踪服务器，主要做调度工作，起负载均衡的作用，在内存中记录集群中所有存储组和存储服务器的状态信息，是客户端和服务器交互的枢纽</li>\n<li>Storage server: 存储服务器(存储节点或服务器)， 文件和文件属性都保存到存储服务器上</li>\n</ul>\n<h3 id=\"重写Django文件存储类\">重写Django文件存储类<a href=\"2019/10/27/项目重点#重写Django文件存储类\"></a></h3><blockquote>\n<p>文件存储类 url()方法的作用：返回name所代表的文件内容的URL</p>\n<p>文件存储类url()方法的触发：content.image.url, 虽然表面上调用的是Imagefield的Url方法。但是内部会去调用文件存储类的url（）方法</p>\n<p>文件存储类url()方法的使用：</p>\n<ul>\n<li>可以通过自定义Django文件存储类达到重写url()方法的目的</li>\n<li>自定义Django文件存储类必须提供url()方法</li>\n</ul>\n</blockquote>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastDFSStorage</span><span class=\"params\">(Storage)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"自定义文件存储系统，修改存储的方案\"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, fdfs_base_url=None)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        构造方法，可以不带参数，也可以携带参数</span></span><br><span class=\"line\"><span class=\"string\">        :param base_url: Storage的IP</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        self.fdfs_base_url = fdfs_base_url <span class=\"keyword\">or</span> settings.FDFS_BASE_URL</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_open</span><span class=\"params\">(self, name, mode=<span class=\"string\">'rb'</span>)</span>:</span></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_save</span><span class=\"params\">(self, name, content)</span>:</span></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">url</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        返回name所指文件的绝对URL</span></span><br><span class=\"line\"><span class=\"string\">        :param name: 要读取文件的引用</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># return 'http://xx.xx.xx.xx:8888/' + name</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.fdfs_base_url + name</span><br></pre></td></tr></table></div></figure>\n\n<p>在<code>settings</code>中要配置如下</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定自定义的Django文件存储类</span></span><br><span class=\"line\">DEFAULT_FILE_STORAGE = <span class=\"string\">'you_app.utils.fastdfs.fdfs_storage.FastDFSStorage'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># FastDFS相关参数</span></span><br><span class=\"line\"><span class=\"comment\"># FDFS_BASE_URL = 'http://xx.xx.xx.xx:8888/'</span></span><br></pre></td></tr></table></div></figure>\n\n<p>全文检索 <code>Elasticsearch</code></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u014526891/article/details/82822647\" target=\"_blank\" rel=\"noopener\">配置</a></li>\n<li>haystack</li>\n</ul>\n<h3 id=\"乐观锁和悲观锁\">乐观锁和悲观锁<a href=\"2019/10/27/项目重点#乐观锁和悲观锁\"></a></h3><blockquote>\n<p>在多个用户同时发起对一个商品的下单请求时，先查询商品库存，在修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常</p>\n</blockquote>\n<ul>\n<li><p>悲观锁</p>\n<p>当查询某条记录时，即让数据库为该记录加锁，锁后别人无法操作，</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select stock from tb_sku where id=1 for update;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SKU.objects.select_for_update().get(id=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></div></figure>\n\n<p>悲观锁会造成死锁</p>\n</li>\n<li><p>乐观锁</p>\n<p>​    乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，者无人更改，否则不在更新库存</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update tb_sku set stock=2 where id=1 and stock=7;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SKU.objects.filter(id=<span class=\"number\">1</span>, stock=<span class=\"number\">7</span>).update(stock=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ul>\n<h3 id=\"Mysql事物隔离级别\">Mysql事物隔离级别<a href=\"2019/10/27/项目重点#Mysql事物隔离级别\"></a></h3><ul>\n<li>事物隔离级别是指的在处理同一个数据的多个事物，一个事物修改数据后，其他事物何时能看到修改的后果</li>\n<li><code>Serializable</code>:串行化， 一个事务一个事务的执行</li>\n<li><code>Repeatable read</code>: 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响</li>\n<li><code>Read committed</code>:读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值</li>\n<li><code>read uncommitted</code>: 读取未提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值</li>\n<li>Mysql数据库默认使用可重复读</li>\n</ul>\n<p>使用乐观锁时，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，使用不能使用可重复读的隔离级别，修改未读取以提交</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class=\"line\">vi mysql.conf</span><br><span class=\"line\">--- transaction-isolation=READ-COMMITTED</span><br></pre></td></tr></table></div></figure>\n\n","prev":{"title":"面试准备复习","link":"2019/11/01/面试准备复习"},"next":{"title":"项目开发","link":"2019/10/26/项目开发"},"plink":"http://jccjd.top/2019/10/27/项目重点/","copyright":{"link":"<a href=\"http://jccjd.top/2019/10/27/项目重点/\" title=\"项目重点\">http://jccjd.top/2019/10/27/项目重点/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}