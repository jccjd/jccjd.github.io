{"title":"面试准备复习","date":"2019-10-31T16:00:00.000Z","link":"2019/11/01/面试准备复习","tags":["面试"],"updated":"2019-11-08T11:55:41.201Z","content":"<h3 id=\"计算机网络\">计算机网络<a href=\"2019/11/01/面试准备复习#计算机网络\"></a></h3><p>OSI七层网络协议:物理层，数据链路层，网络层，运输层，会话层，表示层，应用层 </p>\n<p>物理层： 传输比特流01序列，定义电压，线缆标准接口</p>\n<p>数据链路层：进行寻址，并将数据报或报文段进行装帧，已经出错检测，在尾部打一个CRC</p>\n<p>网络层：ip层</p>\n<h3 id=\"TCP链接\">TCP链接<a href=\"2019/11/01/面试准备复习#TCP链接\"></a></h3><p>在tcp的链接过程中，首先是tcp是一个c/s模式，客户端首先进同步请求<code>syn_sent</code>，发送syn，seq,ack</p>\n<p>服务端发送同步确认<code>syn_rcvd</code>，客户端收到，状态变为建立链接<code>estalished</code>，客户端在发送确认ack，服务端状态变为已建立<code>estalished</code></p>\n<p>断开链接：</p>\n<p>某一方要发送断开链接FIN，fin_wait_1,客户端close_wite, 发送ack， 客户端进入fin_wait2, 服务端发送FIN，进入last_wait, 客户端收到进入time_wait 发送ack，服务端关闭建立</p>\n<p>time_wait 2MSL：重传最后一个ack，确保对方收到    ，因为对方没有收到ack，会有一个超时重传fin，在这个时间段内客户端立刻发送ack </p>\n<h4 id=\"http\">http<a href=\"2019/11/01/面试准备复习#http\"></a></h4><p>告知服务器意图的http方法</p>\n<p>GET：用来请求访问已被url识别的资源 </p>\n<p>POST：用来传输实体的主体</p>\n<p>PUT： 用来传输文文件</p>\n<p>HEAD： 用来确认url的有效性和资源更新的日期时间</p>\n<p>DELETE： 用来删除文件</p>\n<p><strong>持久链接</strong></p>\n<p>在http协议的初始版本中，每进行一个http通信都要断开一次Tcp链接。为了解决该问题在http/1.1， 和部分http/1.0实现持久链接，只要任意一端没有明确提出断开链接，则保持TCp链接状态，能在tcp链接进行多次请求和响应的交互，在http/1.1的默认连接都是持久链接</p>\n<p>http报文结构</p>\n<p>报文首部：服务器端或客户端需要处理的请求或响应的内容和属性</p>\n<p>请求报文首都： 请求行，首部字段</p>\n<p>响应报文：状态行，首部字段</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">首部字段名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Accept</td>\n<td align=\"center\">用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td align=\"center\">Accept-Charset</td>\n<td align=\"center\">优先字符集</td>\n</tr>\n<tr>\n<td align=\"center\">Accept-Language</td>\n<td align=\"center\">优先语言</td>\n</tr>\n<tr>\n<td align=\"center\">From</td>\n<td align=\"center\">用户的邮箱地址</td>\n</tr>\n<tr>\n<td align=\"center\">Host</td>\n<td align=\"center\">请求资源所在服务器</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table></div></div>\n<h4 id=\"IO过程\">IO过程<a href=\"2019/11/01/面试准备复习#IO过程\"></a></h4><p>互联网服务端网络请求的原理：</p>\n<ul>\n<li>获取请求数据，客户端与服务器建立连接发起请求，服务器接受请求</li>\n<li>构建响应，当服务器接受完请求，并在用户空间处理客户端的请求，直到构建响应完成</li>\n<li>返回数据，服务器将已构建好的响应再通过内核空间的网络I/O发给客户端</li>\n</ul>\n<p>阻塞调用与非阻塞调用：</p>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回，非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前进程</p>\n<p>同步处理与异步处理：</p>\n<p>同步处理是指被调用方得到最终结果之后才返回给调用方，异步处理是指被调用方先返回应答，然后在计算调用结果，计算完最终结果在通知并返回给调用方。</p>\n<p>在阻塞io模型中应用程序在从调用recvfrom开始到它返回有数据报准备好的这段时间是阻塞的，recvfrom返回成功，进程开始处理数据报</p>\n<p>在非阻塞模型中，应用程序把一个套接口设置为非阻塞，就是告诉内核，当所请求的i/o操作无法完成时，不要将进程睡眠，而是返回一个错误，应用程序基于i/o操作函数将不断的轮询直到数据准备好</p>\n<p>I/O复用模型，同时阻塞多个i/o模型</p>\n<h3 id=\"数据结构-amp-算法\">数据结构 &amp; 算法<a href=\"2019/11/01/面试准备复习#数据结构-amp-算法\"></a></h3><h4 id=\"线性表\">线性表<a href=\"2019/11/01/面试准备复习#线性表\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init</span><span class=\"params\">(self, size=<span class=\"number\">32</span>)</span>:</span></span><br><span class=\"line\">        self.size = size;</span><br><span class=\"line\">        self._items = [<span class=\"literal\">None</span>] * self.size</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setitem__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        self._items[key] = value</span><br><span class=\"line\">       </span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._items[key]</span><br></pre></td></tr></table></div></figure>\n\n\n\n<h4 id=\"单链表\">单链表<a href=\"2019/11/01/面试准备复习#单链表\"></a></h4><h4 id=\"双链表\">双链表<a href=\"2019/11/01/面试准备复习#双链表\"></a></h4><h4 id=\"循环双链表\">循环双链表<a href=\"2019/11/01/面试准备复习#循环双链表\"></a></h4><h4 id=\"队列\">队列<a href=\"2019/11/01/面试准备复习#队列\"></a></h4><h4 id=\"堆栈\">堆栈<a href=\"2019/11/01/面试准备复习#堆栈\"></a></h4><h4 id=\"二叉树\">二叉树<a href=\"2019/11/01/面试准备复习#二叉树\"></a></h4><h4 id=\"冒泡排序\">冒泡排序<a href=\"2019/11/01/面试准备复习#冒泡排序\"></a></h4><h4 id=\"选择排序\">选择排序<a href=\"2019/11/01/面试准备复习#选择排序\"></a></h4><h4 id=\"插入排序\">插入排序<a href=\"2019/11/01/面试准备复习#插入排序\"></a></h4><h4 id=\"快速排序\">快速排序<a href=\"2019/11/01/面试准备复习#快速排序\"></a></h4><h4 id=\"归并排序\">归并排序<a href=\"2019/11/01/面试准备复习#归并排序\"></a></h4><h3 id=\"操作系统\">操作系统<a href=\"2019/11/01/面试准备复习#操作系统\"></a></h3><h4 id=\"select-poll-和epoll\">select, poll 和epoll<a href=\"2019/11/01/面试准备复习#select-poll-和epoll\"></a></h4><p>对于一个network IO， 会涉及到两个系统对象，一个是调用这个io的process另一个是系统内核<code>kernel</code>当一个read操作发生时，它会经历两个阶段：</p>\n<ul>\n<li>等待数据准备<code>Waiting for the data to be ready</code></li>\n<li>将数据从内核拷贝到进程中<code>Copying the data from the kernel to the process</code></li>\n</ul>\n<p><em>文件描述符</em></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/sys/fs/file-max </span><br><span class=\"line\">&gt;&gt; 773942</span><br></pre></td></tr></table></div></figure>\n\n\n\n<h4 id=\"阻塞\">阻塞<a href=\"2019/11/01/面试准备复习#阻塞\"></a></h4><p>当用户进程调用<strong>recvfrom</strong>这个系统调用， kernel开始了IO的第一阶段：准备数据。对于<code>network io</code>很多时候数据在一开始还没到达，这个时候kernel就要等待足够的数据到来，而在用户进程，整个进程会被阻塞，阻塞io的特点就是在io执行的两个阶段都被block</p>\n<h4 id=\"select运行机制\">select运行机制<a href=\"2019/11/01/面试准备复习#select运行机制\"></a></h4><p>select（）的机制中提供一种fd_set的数据结构，实际上是一个long型的数组，每一个数组元素都能力与一打开的文件句柄建立联系，当调用select()时由内核根据IO的状态修改fd_set的内容，由此来通知实行了select的进程那个socket或文件可读，</p>\n<ul>\n<li>每次调用select都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，开销变大</li>\n<li>同时每次调用select都需要在内核遍历传递进来的所有fd_set,如果fd_set集合很大时，开销同样大</li>\n<li>为了减少数据拷贝带来的性能损害，内核对被监控的fd_set集合大小做了限制，1024</li>\n</ul>\n<h4 id=\"Poll\">Poll<a href=\"2019/11/01/面试准备复习#Poll\"></a></h4><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符的数量限制，</p>\n<h4 id=\"epoll\">epoll<a href=\"2019/11/01/面试准备复习#epoll\"></a></h4><p>相对与select来说，epoll没有文件描述符个数的限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件放到内核的一个事件表中，这样在用户空间和内核空间的copy只需要一次</p>\n<h4 id=\"三者之间的区别\">三者之间的区别<a href=\"2019/11/01/面试准备复习#三者之间的区别\"></a></h4><div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th></th>\n<th align=\"center\">select</th>\n<th align=\"center\">poll</th>\n<th align=\"center\">epoll</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>操作方式</td>\n<td align=\"center\">遍历</td>\n<td align=\"center\">遍历</td>\n<td align=\"center\">回调</td>\n</tr>\n<tr>\n<td>底层实现</td>\n<td align=\"center\">数组</td>\n<td align=\"center\">链表</td>\n<td align=\"center\">哈希表</td>\n</tr>\n<tr>\n<td>IO效率</td>\n<td align=\"center\">每次调用都进行线性遍历</td>\n<td align=\"center\">每次都进行线性遍历</td>\n<td align=\"center\">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readList里面，O(1)</td>\n</tr>\n<tr>\n<td>最大链接数</td>\n<td align=\"center\">1024</td>\n<td align=\"center\">无上限</td>\n<td align=\"center\">无上限</td>\n</tr>\n<tr>\n<td>fd拷贝</td>\n<td align=\"center\">每次都要把fd集合从用户态拷贝到内核态</td>\n<td align=\"center\">每次调用都要将用户态拷贝到内核态</td>\n<td align=\"center\">只拷贝一次</td>\n</tr>\n</tbody></table></div></div>\n<h4 id=\"调度算法\">调度算法<a href=\"2019/11/01/面试准备复习#调度算法\"></a></h4><ul>\n<li>先来先服务</li>\n<li>短作业优先</li>\n<li>最高优先权调度</li>\n<li>时间片轮转</li>\n</ul>\n<h4 id=\"死锁\">死锁<a href=\"2019/11/01/面试准备复习#死锁\"></a></h4><p>死锁产生的原因：竞争资源，程序的推进的顺序不当</p>\n<p>必要条件：互斥，请求与保持，不剥夺，环路等待</p>\n<p>处理死锁的基本方法：预防死锁，银行家算法， </p>\n<h3 id=\"面向对象编程（object-oriented-programming）\">面向对象编程（object oriented programming）<a href=\"2019/11/01/面试准备复习#面向对象编程（object-oriented-programming）\"></a></h3><p>面向对象编程，什么是对象，类的实例叫对象，怎么面向对象编程，对类的实例的一系列的操作叫做面向对象编程，类是什么类是对一类物体特征的抽象，定义了包括数据的形式和对数据的操作。对某一事物抽象成类，对类中数据的操作细节是没有必要对外公开的，还有一些数据是不能对外公开的，那么就需要对其进行保护这就是封装，由于类是对某一事务的抽象，那么这个抽象的程度不同那么会产生不同的类，低抽象程度的类可以在高抽象程度的类的基础上进行细节的扩展，那么就产生了继承的概念，最低程度的抽象就是实例，在继承过程中</p>\n<h3 id=\"系统设计\">系统设计<a href=\"2019/11/01/面试准备复习#系统设计\"></a></h3><h3 id=\"Python\">Python<a href=\"2019/11/01/面试准备复习#Python\"></a></h3><p><strong>数据类型</strong></p>\n<h3 id=\"Django\">Django<a href=\"2019/11/01/面试准备复习#Django\"></a></h3><ul>\n<li>django是一个大而全的框架，有全自动化的管理后台，只需要使用orm，做简单的对象定义就能生成数据库结构，以及全功能的管理后台</li>\n<li>django内置的orm跟框架内的其他模块耦合程度高</li>\n<li>django的开发效率高，但性能有限制</li>\n</ul>\n<p>django的请求生命周期</p>\n<ul>\n<li>wsgi请求封装后交给web框架</li>\n<li>中间件，对请求进行校验或在请求对象中添加其他相关数据，csrf，request.session</li>\n<li>路由匹配，根据浏览器发送的不同url去匹配不同的视图函数</li>\n<li>视图函数，在视图函数中进行业务逻辑处理，可能涉及到：orm， template 渲染</li>\n<li>wsgi，将响应的内容发送给浏览器</li>\n</ul>\n<p><strong>中间件</strong></p>\n<p>中间件是介于request和response处理之间的一道处理过程，在全局范围内改变django的输入和输出，中间件帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，</p>\n<p><strong>WSGI</strong></p>\n<p><code>web server gateway interface</code> 是用来指定web服务器和python web应用程序或框架之间的标准接口</p>\n<p>wsgi协议要求面对两个端，一个是服务器或者说是网关端，一个是应用程序或者说是框架端，服务端调用应用程序端提供的可调用对象 </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_app</span><span class=\"params\">(environ, start_response)</span>:</span></span><br><span class=\"line\">\tstatus = <span class=\"string\">'200 OK'</span></span><br><span class=\"line\">    response_headers = [(<span class=\"string\">'Content-type'</span>, <span class=\"string\">'text/plain'</span>)]</span><br><span class=\"line\">    start_response(status,  response_headers)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'Hello world!\\n'</span>]</span><br></pre></td></tr></table></div></figure>\n\n\n\n<h3 id=\"Redis\">Redis<a href=\"2019/11/01/面试准备复习#Redis\"></a></h3><h3 id=\"Mysql\">Mysql<a href=\"2019/11/01/面试准备复习#Mysql\"></a></h3><h4 id=\"事务\">事务<a href=\"2019/11/01/面试准备复习#事务\"></a></h4><p>数据库事务是指单个逻辑要么全执行要么不执行</p>\n<ul>\n<li>原子性：事务是最小的执行单位，要吗全执行，要么不执行</li>\n<li>一致性：执行事务前后数据保持一直</li>\n<li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务数据库独立</li>\n<li>持久性：当事务被提交之后，对事务的改变是持久的，即数据库发生故障也不应该对其有影响</li>\n</ul>\n<p>使用事务会产生问题：当一个事务对数据修改但未提交，然后另外一个事务访问了改数据那么这个数据就是脏数据，也叫脏读。一个事务修改，另一个事务覆盖修改，叫丢失修改。一个事务多次读取数据，在两次读取之间数据被修改，那么导致两次数据不一致，叫不可重复读，还有一种幻读和这个相似，两次读取数据多了，为了解决这个问题主要使用事务隔离事务级别，对脏读用Read-uncomiit，Read-commit，reperatable-read，serializer</p>\n<p>不可重复读的问题不是不可重复读，而是重复读的时候出问题了两次结果不同，我要两次结果一致，能重复读</p>\n<p>事务隔离级别</p>\n<ul>\n<li>Read-uncommited：读取未提交</li>\n<li>read-commited: 读取以提交</li>\n<li>repeatable-read:对同一字段的多次读取结果都是一直的</li>\n<li>serializers: 最高隔离级别，</li>\n</ul>\n<h4 id=\"数据库索引\">数据库索引<a href=\"2019/11/01/面试准备复习#数据库索引\"></a></h4><p>在建立表时 都要为表增加主键，再增加主键的时候其实就是将表转换成一个平衡树了，那么这个平衡树了，整个表就变成一个聚集索引了默认索引是id如果没有指定其他自增主键的话，</p>\n<p>非聚集索引，如果给表中多个字段加上索引，那么就会多出多个独立索引，每个独立索引之间互不关联，没给一个字段新建一个索引，字段中的数据就会被复制一份出来，用于生成索引，因此给表添加索引会增加表的体积，占用磁盘存储空间</p>\n<p>不管以任何方式查询表，最终会利用主键通过聚集索引来定位到数据，聚集索引是通往真是数据所在的唯一路径</p>\n<p>数据库索引是一个什么东西能，反正是说添加数据库索引能够提高数据库的查询数据效率，但是会降低用户插入和删除的效率，为啥会这样呢，又是据听说这个索引它实现的数据结构是B+tree ，那这个树是个啥呢，据听说是个平衡树的变种，可以多个树叉，可以降低树的深度，方便查找由于这个树是已经排序好的所以可以按照二分法很简单的找到目标数据，但是为了维护这个树要一点空间开销，而且在插入删除的时候树会变化左旋，右旋，具体怎么变的咱暂时还不是很清楚，只知道和平衡二叉排序树很想但要比那个复杂度要高，规则更多暂不做研究，要更改数据在磁盘中的位置，增大了IO输出，所以不适合增加删除，只能提高查找，</p>\n<h3 id=\"工具\">工具<a href=\"2019/11/01/面试准备复习#工具\"></a></h3>","prev":{"title":"mysql的访问设置","link":"2019/11/04/mysql的访问设置"},"next":{"title":"项目重点","link":"2019/10/27/项目重点"},"plink":"http://jccjd.top/2019/11/01/面试准备复习/","copyright":{"link":"<a href=\"http://jccjd.top/2019/11/01/面试准备复习/\" title=\"面试准备复习\">http://jccjd.top/2019/11/01/面试准备复习/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}