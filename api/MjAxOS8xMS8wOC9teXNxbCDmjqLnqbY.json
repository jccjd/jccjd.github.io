{"title":"mysql 探究","date":"2019-11-07T16:00:00.000Z","link":"2019/11/08/mysql 探究","tags":["mysql"],"updated":"2019-11-09T01:59:13.759Z","content":"<h3 id=\"什么是mysql\">什么是mysql<a href=\"2019/11/08/mysql 探究#什么是mysql\"></a></h3><blockquote>\n<p><code>mysql</code>是一种关系型数据库， 是非常常用的数据库，<code>mysql</code>是开源的，方便扩展，mysql的默认端口是<code>3306</code></p>\n</blockquote>\n<h3 id=\"mysql的两种引擎\">mysql的两种引擎<a href=\"2019/11/08/mysql 探究#mysql的两种引擎\"></a></h3><blockquote>\n<p><strong>MYISAM:</strong> 不支持事务，不支持外键，表锁，插入数据时锁定整张表，查询函数时无需扫描整表</p>\n<p><strong>INNODB:</strong> 支持事务，支持外键，行锁，查表总行数时，全表扫描</p>\n</blockquote>\n<p><em>与sql标准不同的地方在于InnoDB存储引擎在 <code>repeatable-read</code>事务隔离级别下使用的是 <code>Next-key Lock</code>锁算法，因此可以避免幻读的产生，InnoDB在分布式事务的情况下会用到<code>serilaizable</code>隔离级别</em></p>\n<h3 id=\"事务\">事务<a href=\"2019/11/08/mysql 探究#事务\"></a></h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p>\n<p>事务的四大特性：</p>\n<ul>\n<li>原子性: 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</li>\n<li>一致性: 执行事务前后，数据保持一致，多个事务对同一数据读取的结果是相同的；</li>\n<li>隔离性: 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li>\n<li>持久性: 一个事务被提交之后。它对数据库中的改变是持久的，即数据库发生故障也不应该对其有任何影响</li>\n</ul>\n<p><strong>并发事务的问题：</strong></p>\n<blockquote>\n<p><strong>脏读：</strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务以访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，</p>\n<p><strong>丢失修改：</strong>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改这个数据后，第二个事务以修改了这个数据，这样第一个事务内的修改结果就被丢失，因此称为丢失修改</p>\n<p><strong>不可重复读：</strong>在一个事务内多次读取一个数据。在整个事务还没结束时，另一个事务以访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一样，</p>\n<p><strong>幻读：</strong>幻读与不可重复读类似。它发生在一个事务读取几行数据，然后另一个事务插入了一些数据，在随后的查询中，第一个事务发现多了一些原本不存在的记录，</p>\n</blockquote>\n<h3 id=\"事务的隔离级别\">事务的隔离级别<a href=\"2019/11/08/mysql 探究#事务的隔离级别\"></a></h3><blockquote>\n<p><strong>read-uncommitted:</strong> 最低的隔离级别，允许读取尚未提交的数据变更</p>\n<p><strong>read-committed:</strong> 允许读取并发事务已经提交的数据，</p>\n<p><strong>repeatable-read:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务修改</p>\n<p><strong>serilizable:</strong> 最高级别的隔离，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。</p>\n</blockquote>\n<p><strong>隔离级别解决事务问题</strong></p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">read-uncommitted</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">read-committed</td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">repeatable-read</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td align=\"center\">serilalizable</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n</tr>\n</tbody></table></div></div>\n<p><em>事务隔离级别为读提交时，写数据只会锁住响应行</em></p>\n<p><em>事务隔离级别为可重复读时，如果检索条件有索引，默认加锁方式是next-key，如果检索条件没有索引，更新数据时会锁住整张表，</em></p>\n<p><em>事务隔离级别为串行化时，读写数据都会锁住整张表</em></p>\n<p><em>隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响有越大</em></p>\n<h3 id=\"索引\">索引<a href=\"2019/11/08/mysql 探究#索引\"></a></h3><p>使用索引能够提高MySQL的查询效率，</p>\n<p>………….</p>\n","next":{"title":"mysql的访问设置","link":"2019/11/04/mysql的访问设置"},"plink":"http://jccjd.top/2019/11/08/mysql 探究/","copyright":{"link":"<a href=\"http://jccjd.top/2019/11/08/mysql 探究/\" title=\"mysql 探究\">http://jccjd.top/2019/11/08/mysql 探究/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}